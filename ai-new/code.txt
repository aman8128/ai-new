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 --> hugging-face

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 --> groqcloud

sk-3UnY9eVsTHi0V0NCCa5mVY61FwL4djjKakG7V3ePqs9vorgi --> stability

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 --> OpenRouter-1

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 --> OpenRouter-2

sk-aff8c5ba30f34d629725bab7d0546a3f --> deepseek ai

948700561843-utfo5pj26sc7anp5395n1cdtseonu64l.apps.googleusercontent.com --> google client id

import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import './home.css';

function Home() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatHistory, setChatHistory] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [isSidebarVisible, setIsSidebarVisible] = useState(true);
  const messagesEndRef = useRef(null);
  const userId = useRef("user_" + Math.random().toString(36).substr(2, 9));
  const typingIntervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const botMessageIdRef = useRef(null);
  const [isTyping, setIsTyping] = useState(false);
  const inputRef = useRef(null);

  useEffect(() => {
    return () => {
      if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
    };
  }, []);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    // Create default chat on first load
    if (chatHistory.length === 0) {
      const defaultChat = {
        id: Date.now(),
        title: 'New Chat',
        messages: []
      };
      setChatHistory([defaultChat]);
      setActiveChat(defaultChat.id);
      setMessages([]);
    }
  }, []);

  const toggleSidebar = () => {
    setIsSidebarVisible(!isSidebarVisible);
  };

  const cancelRequest = () => {
    if (abortControllerRef.current) abortControllerRef.current.abort();
    if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
    botMessageIdRef.current = null;
    setIsProcessing(false);
    setIsTyping(false);
    setMessages(prev => prev.filter(msg => msg.type !== 'typing'));
  };

  const startNewChat = () => {
    if (isTyping || isProcessing) {
      alert("Please wait! AI is still typing. Let it finish before starting a new chat.");
      return;
    }

    // Check if current chat is empty
    const currentChat = chatHistory.find(chat => chat.id === activeChat);
    const isCurrentChatEmpty = currentChat?.messages?.length === 0;

    // If current chat is empty, just return to it without creating new one
    if (isCurrentChatEmpty && currentChat.title === 'New Chat') {
      setMessages([]);
      setActiveChat(currentChat.id);
      return;
    }

    // If current chat has messages, save it
    if (messages.length > 0) {
      const newChat = {
        id: Date.now(),
        title: generateChatTitle(messages),
        messages: [...messages]
      };
      setChatHistory(prev => [newChat, ...prev]);
    }

    // Check if there's already an empty chat
    const existingEmptyChat = chatHistory.find(chat => 
      chat.messages.length === 0 && chat.title === 'New Chat'
    );
    
    if (existingEmptyChat) {
      // Switch to existing empty chat
      setMessages([]);
      setActiveChat(existingEmptyChat.id);
    } else {
      // Create new empty chat
      const emptyChat = {
        id: Date.now(),
        title: "New Chat",
        messages: []
      };
      setChatHistory(prev => [emptyChat, ...prev]);
      setMessages([]);
      setActiveChat(emptyChat.id);
    }
  };

  const generateChatTitle = (messages) => {
    const firstUserMessage = messages.find(msg => msg.sender === 'user');
    if (firstUserMessage) {
      const shortText = firstUserMessage.text.replace(/\n/g, ' ').trim().slice(0, 20);
      return shortText + (firstUserMessage.text.length > 20 ? '...' : '');
    }
    return `New Chat ${new Date().toLocaleTimeString()}`;
  };

  const loadChat = (chatId) => {
    const chat = chatHistory.find(c => c.id === chatId);
    if (chat) {
      setMessages(chat.messages);
      setActiveChat(chatId);
    }
  };

  const formatMessageContent = (text) => {
    // Simple code block formatting
    const codeBlockRegex = /```(\w+)?\n([\s\S]+?)\n```/g;
    const parts = [];
    let lastIndex = 0;
    
    text.replace(codeBlockRegex, (match, language, code, offset) => {
      // Add text before code block
      if (offset > lastIndex) {
        parts.push(
          <div key={lastIndex} className="message-text">
            {text.substring(lastIndex, offset)}
          </div>
        );
      }
      
      // Add simple code block without syntax highlighting
      parts.push(
        <div key={offset} className="code-block mt-2 mb-3 p-2 bg-dark text-white rounded">
          <pre className="m-0" style={{ whiteSpace: 'pre-wrap' }}>
            <code>{code}</code>
          </pre>
        </div>
      );
      
      lastIndex = offset + match.length;
      return match;
    });
    
    // Add remaining text after last code block
    if (lastIndex < text.length) {
      parts.push(
        <div key={lastIndex} className="message-text">
          {text.substring(lastIndex)}
        </div>
      );
    }
    
    return parts.length ? parts : <div className="message-text">{text}</div>;
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!inputValue.trim() || isProcessing) return;

    const userMessage = {
      id: Date.now(),
      text: inputValue,
      type: 'text',
      sender: 'user'
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInputValue('');
    setIsProcessing(true);
    setIsTyping(true);

    const typingMessageId = Date.now() + 0.1;
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: ''
    }]);

    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt: userMessage.text, user_id: userId.current }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) throw new Error(`Server error: ${response.status}`);
      const data = await response.json();
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      const responseText = data.response || data.content || JSON.stringify(data);
      const botMessageId = Date.now() + 1;
      botMessageIdRef.current = botMessageId;

      setMessages(prev => [...prev, {
        id: botMessageId,
        type: 'text',
        sender: 'bot',
        text: ''
      }]);

      let currentIndex = 0;
      typingIntervalRef.current = setInterval(() => {
        if (currentIndex < responseText.length) {
          setMessages(prev =>
            prev.map(msg =>
              msg.id === botMessageId
                ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                : msg
            )
          );
          currentIndex++;
        } else {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
          botMessageIdRef.current = null;
          setIsTyping(false);

          const finalMessage = {
            id: botMessageId,
            type: 'text',
            sender: 'bot',
            text: responseText
          };

          if (!activeChat) {
            const title = generateChatTitle([userMessage]);
            const newChat = {
              id: Date.now(),
              title,
              messages: [userMessage, finalMessage]
            };
            setChatHistory(prev => [newChat, ...prev]);
            setActiveChat(newChat.id);
          } else {
            setChatHistory(prev =>
              prev.map(chat =>
                chat.id === activeChat
                  ? {
                      ...chat,
                      title: chat.title === 'New Chat'
                        ? generateChatTitle([userMessage])
                        : chat.title,
                      messages: [...chat.messages, userMessage, finalMessage]
                    }
                  : chat
              )
            );
          }
        }
      }, 20);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not get response from server'
        }]);
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const handleButtonClick = (e) => {
    if (isProcessing || isTyping) {
      cancelRequest();
    } else {
      handleSendMessage(e);
    }
  };

  return (
    <div className="d-flex">
      {/* Sidebar */}
      <div className={`sidebar bg-white shadow ${isSidebarVisible ? 'visible' : 'hidden'}`}>
        <div className="p-3 border-bottom">
          <button 
            onClick={startNewChat} 
            className="btn btn-outline-secondary w-100"
          >
            + New Chat
          </button>
        </div>
        <div className="p-2">
          <h6 className="px-2 py-1 text-muted">Chat History</h6>
          <div className="list-group list-group-flush">
            {chatHistory.map(chat => (
              <button
                key={chat.id}
                onClick={() => loadChat(chat.id)}
                className={`list-group-item list-group-item-action text-truncate ${activeChat === chat.id ? 'active' : ''}`}
                title={chat.title}
              >
                {chat.title}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Chat Section */}
      <div className={`flex-grow-1 d-flex flex-column vh-100 ${isSidebarVisible ? 'ms-sidebar' : ''}`}>
        <div className="bg-success text-white p-3 d-flex align-items-center justify-content-between sticky-top">
          <button className="btn btn-light me-2" onClick={toggleSidebar}>☰</button>
          <h4 className="mb-0 font-weight-bold">
            {chatHistory.find(c => c.id === activeChat)?.title || 'New Chat'}
          </h4>
          <div style={{ width: 40 }}></div>
        </div>

        <div className="flex-grow-1 overflow-auto p-3">
          <div className="d-flex flex-column gap-3">
            {messages.map((msg) => (
              <div key={msg.id} className={`d-flex ${msg.sender === 'user' ? 'justify-content-end' : 'justify-content-start'}`}>
                <div className={`p-3 rounded-3 ${msg.sender === 'user' ? 'bg-primary text-white' : msg.type === 'typing' ? 'bg-light' : 'bg-light text-dark'}`} style={{ maxWidth: '70%' }}>
                  {msg.type === 'typing' ? (
                    <div className="d-flex align-items-center gap-2">
                      <div className="spinner-grow spinner-grow-sm text-secondary" role="status">
                        <span className="visually-hidden">Typing...</span>
                      </div>
                      <span className="text-muted">Thinking...</span>
                    </div>
                  ) : (
                    <div style={{ whiteSpace: 'pre-wrap', textAlign: 'left' }}>
                      {msg.sender === 'bot' ? (
                        <div className="bot-message-content">
                          <h5 className="font-weight-bold mb-2">AI Assistant</h5>
                          {formatMessageContent(msg.text)}
                        </div>
                      ) : (
                        <div className="user-message-content">
                          <h5 className="font-weight-bold mb-2">You</h5>
                          <div className="message-text">{msg.text}</div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            ))}
            <div ref={messagesEndRef} />
          </div>
        </div>

        <form onSubmit={handleSendMessage} className="p-3 border-top">
          <div className="input-group">
            <input
              type="text"
              className="form-control rounded-pill ps-4"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={(e) => {
                if ((isProcessing || isTyping) && e.key === 'Enter') {
                  e.preventDefault();
                }
              }}
              placeholder="Type your message..."
              ref={inputRef}
            />
            <button
              type="button"
              className={`btn ms-2 rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping ? 'btn-danger' : 'btn-primary'}`}
              onClick={handleButtonClick}
              disabled={!inputValue.trim() && !(isProcessing || isTyping)}
              style={{ minWidth: '80px' }}
            >
              {(isProcessing || isTyping) ? (
                <>
                  <span className="spinner-border spinner-border-sm" role="status" />
                </>
              ) : 'Send'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

export default Home;

<button
              type="button"
              className={`btn ms-2 rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping ? 'btn-secondary' : 'btn-secondary'}`}
              onClick={handleButtonClick}
              disabled={!inputValue.trim() && !(isProcessing || isTyping)}
            >
              {(isProcessing || isTyping) ? (
                <span className="spinner-border spinner-border-sm text-light" role="status" />
              ) : 'Send'}
            </button>

<div className="bg-success text-white p-3 d-flex align-items-center justify-content-between sticky-top">
          <button className="btn btn-light me-2" onClick={toggleSidebar}>☰</button>
          <h4 className="mb-0 font-weight-bold">
            {chatHistory.find(c => c.id === activeChat)?.title || 'New Chat'}
          </h4>
          <div style={{ width: 40 }}></div>
        </div>


import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import './home.css';
import 'bootstrap-icons/font/bootstrap-icons.css';

function Home() {
  // State management
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatHistory, setChatHistory] = useState([]);
  const [archivedChats, setArchivedChats] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [isSidebarVisible, setIsSidebarVisible] = useState(true);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [chatToDelete, setChatToDelete] = useState(null);
  const [showArchived, setShowArchived] = useState(false);
  const [showRenameModal, setShowRenameModal] = useState(false);
  const [newChatTitle, setNewChatTitle] = useState('');
  const [chatToRename, setChatToRename] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  
  // Refs
  const messagesEndRef = useRef(null);
  const userId = useRef("user_" + Math.random().toString(36).substr(2, 9));
  const typingIntervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const botMessageIdRef = useRef(null);
  const inputRef = useRef(null);
  const sidebarRef = useRef(null);

  // Constants
  const TOAST_DURATION = 3000;
  const TYPING_SPEED = 20; // milliseconds per character

  // Toast container style
  const toastContainerStyle = {
    position: 'fixed',
    top: '20px',
    right: '20px',
    zIndex: 1100,
    display: 'flex',
    flexDirection: 'column',
    gap: '10px'
  };

  // Effects
  useEffect(() => {
    // Cleanup on unmount
    return () => {
      if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
    };
  }, []);

  useEffect(() => {
    // Scroll to bottom when messages change
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    // Focus input when not processing
    if (!isProcessing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isProcessing]);

  useEffect(() => {
    // Initialize with default chat if empty
    if (chatHistory.length === 0) {
      const defaultChat = {
        id: Date.now(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory([defaultChat]);
      setActiveChat(defaultChat.id);
    }
  }, []);

  useEffect(() => {
    // Close sidebar when clicking outside
    const handleClickOutside = (event) => {
      if (sidebarRef.current && !sidebarRef.current.contains(event.target)) {
        if (window.innerWidth < 768) {
          setIsSidebarVisible(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Helper functions
  const showToast = (type, message) => {
    const toastElement = document.getElementById(`${type}Toast`);
    if (toastElement) {
      const toast = new window.bootstrap.Toast(toastElement, {
        delay: TOAST_DURATION
      });
      toast.show();
    }
  };

  const generateChatTitle = (messages) => {
    const firstUserMessage = messages.find(msg => msg.sender === 'user');
    if (firstUserMessage) {
      const shortText = firstUserMessage.text
        .replace(/\n/g, ' ')
        .trim()
        .slice(0, 30);
      return shortText + (firstUserMessage.text.length > 30 ? '...' : '');
    }
    return `New Chat ${new Date().toLocaleTimeString()}`;
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
    });
  };

  // Chat operations
  const toggleSidebar = () => setIsSidebarVisible(!isSidebarVisible);

  const cancelRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      showToast('info', 'Request cancelled');
    }
    if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
    botMessageIdRef.current = null;
    setIsProcessing(false);
    setIsTyping(false);
    setMessages(prev => prev.filter(msg => msg.type !== 'typing'));
  };

  const startNewChat = () => {
    if (isTyping || isProcessing) {
      showToast('warning', 'Please wait for the current response to finish');
      return;
    }

    const emptyChat = chatHistory.find(chat => chat.messages.length === 0);
    if (emptyChat) {
      setActiveChat(emptyChat.id);
      setMessages([]);
    } else {
      const currentChat = chatHistory.find(chat => chat.id === activeChat);
      const hasBotMessage = messages.some(msg => msg.sender === 'bot');

      if (currentChat && hasBotMessage) {
        const updatedChat = {
          ...currentChat,
          messages: [...messages],
          title: currentChat.title === 'New Chat' ? generateChatTitle(messages) : currentChat.title,
          updatedAt: new Date().toISOString()
        };

        const updatedHistory = chatHistory.map(chat =>
          chat.id === activeChat ? updatedChat : chat
        );
        setChatHistory(updatedHistory);
      }

      const newChat = {
        id: Date.now(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory(prev => [newChat, ...prev]);
      setMessages([]);
      setActiveChat(newChat.id);
    }
  };

  const loadChat = (chatId) => {
    const chat = [...chatHistory, ...archivedChats].find(c => c.id === chatId);
    if (chat) {
      setMessages(chat.messages);
      setActiveChat(chatId);
      
      // Close sidebar on mobile
      if (window.innerWidth < 768) {
        setIsSidebarVisible(false);
      }
    }
  };

  const handleShare = async (chatId) => {
    const chat = [...chatHistory, ...archivedChats].find(c => c.id === chatId);
    if (!chat) return;

    try {
      const content = chat.messages.map(msg => 
        `${msg.sender === 'user' ? 'You' : 'Assistant'}: ${msg.text}`
      ).join('\n\n');
      
      await navigator.clipboard.writeText(content);
      showToast('success', 'Chat copied to clipboard!');
    } catch (err) {
      showToast('error', 'Failed to copy chat');
    }
  };

  const handleArchive = (chatId) => {
    const chat = chatHistory.find(c => c.id === chatId);
    if (!chat) return;

    setArchivedChats(prev => [{
      ...chat,
      archivedAt: new Date().toISOString()
    }, ...prev]);
    setChatHistory(prev => prev.filter(c => c.id !== chatId));
    
    if (activeChat === chatId) {
      setMessages([]);
      setActiveChat(null);
    }
    
    showToast('success', 'Chat has been archived');
  };

  const handleUnarchive = (chatId) => {
    const chat = archivedChats.find(c => c.id === chatId);
    if (!chat) return;

    setChatHistory(prev => [{
      ...chat,
      archivedAt: undefined
    }, ...prev]);
    setArchivedChats(prev => prev.filter(c => c.id !== chatId));
    
    showToast('success', 'Chat has been unarchived');
  };

  const confirmDelete = (chatId) => {
    setChatToDelete(chatId);
    setShowDeleteModal(true);
  };

  const handleDelete = () => {
    if (!chatToDelete) return;
    
    const updatedHistory = chatHistory.filter(chat => chat.id !== chatToDelete);
    const updatedArchived = archivedChats.filter(chat => chat.id !== chatToDelete);
    
    setChatHistory(updatedHistory);
    setArchivedChats(updatedArchived);
    
    if (activeChat === chatToDelete) {
      setMessages([]);
      setActiveChat(null);
    }
    
    setShowDeleteModal(false);
    setChatToDelete(null);
    
    showToast('success', 'Chat has been deleted');
  };

  const confirmRename = (chatId, currentTitle) => {
    setChatToRename(chatId);
    setNewChatTitle(currentTitle);
    setShowRenameModal(true);
  };

  const handleRename = () => {
    if (!chatToRename || !newChatTitle.trim()) return;
    
    setChatHistory(prev =>
      prev.map(chat =>
        chat.id === chatToRename
          ? { ...chat, title: newChatTitle, updatedAt: new Date().toISOString() }
          : chat
      )
    );
    
    setArchivedChats(prev =>
      prev.map(chat =>
        chat.id === chatToRename
          ? { ...chat, title: newChatTitle, updatedAt: new Date().toISOString() }
          : chat
      )
    );
    
    setShowRenameModal(false);
    setChatToRename(null);
    setNewChatTitle('');
    
    showToast('success', 'Chat title updated');
  };

  const formatMessageContent = (text) => {
    if (!text) return null;
    
    const paragraphs = text.split('\n\n');
    return paragraphs.map((paragraph, index) => {
      if (paragraph.trim() === '') return null;
      
      // Heading detection
      if (paragraph.trim().endsWith(':')) {
        return <h6 key={index} className="message-heading">{paragraph}</h6>;
      }
      
      // Code block detection
      if (paragraph.startsWith('```') && paragraph.endsWith('```')) {
        const code = paragraph.slice(3, -3).trim();
        return (
          <div key={index} className="code-block">
            <pre><code>{code}</code></pre>
          </div>
        );
      }
      
      // List detection
      if (paragraph.startsWith('- ') || paragraph.startsWith('* ')) {
        const items = paragraph.split('\n');
        return (
          <ul key={index} className="message-list">
            {items.map((item, i) => (
              <li key={i}>{item.replace(/^[-*] /, '')}</li>
            ))}
          </ul>
        );
      }
      
      // Numbered list detection
      if (/^\d+\.\s/.test(paragraph)) {
        const items = paragraph.split('\n');
        return (
          <ol key={index} className="message-list">
            {items.map((item, i) => (
              <li key={i}>{item.replace(/^\d+\.\s/, '')}</li>
            ))}
          </ol>
        );
      }
      
      // Default paragraph
      return <p key={index} className="message-paragraph">{paragraph}</p>;
    });
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!inputValue.trim() || isProcessing) return;

    const userMessage = {
      id: Date.now(),
      text: inputValue,
      type: 'text',
      sender: 'user',
      timestamp: new Date().toISOString()
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInputValue('');
    setIsProcessing(true);
    setIsTyping(true);

    const typingMessageId = Date.now() + 0.1;
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: '',
      timestamp: new Date().toISOString()
    }]);

    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({ 
          prompt: userMessage.text, 
          user_id: userId.current,
          chat_id: activeChat
        }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }

      const data = await response.json();
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      const responseText = data.response || data.content || JSON.stringify(data);
      const botMessageId = Date.now() + 1;
      botMessageIdRef.current = botMessageId;

      setMessages(prev => [...prev, {
        id: botMessageId,
        type: 'text',
        sender: 'bot',
        text: '',
        timestamp: new Date().toISOString()
      }]);

      let currentIndex = 0;
      typingIntervalRef.current = setInterval(() => {
        if (currentIndex < responseText.length) {
          setMessages(prev =>
            prev.map(msg =>
              msg.id === botMessageId
                ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                : msg
            )
          );
          currentIndex++;
        } else {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
          botMessageIdRef.current = null;
          setIsTyping(false);

          const finalMessage = {
            id: botMessageId,
            type: 'text',
            sender: 'bot',
            text: responseText,
            timestamp: new Date().toISOString()
          };

          if (!activeChat) {
            const title = generateChatTitle([userMessage]);
            const newChat = {
              id: Date.now(),
              title,
              messages: [userMessage, finalMessage],
              createdAt: new Date().toISOString()
            };
            setChatHistory(prev => [newChat, ...prev]);
            setActiveChat(newChat.id);
          } else {
            setChatHistory(prev =>
              prev.map(chat =>
                chat.id === activeChat
                  ? {
                      ...chat,
                      title: chat.title === 'New Chat'
                        ? generateChatTitle([userMessage])
                        : chat.title,
                      messages: [...chat.messages, userMessage, finalMessage],
                      updatedAt: new Date().toISOString()
                    }
                  : chat
              )
            );
          }
        }
      }, TYPING_SPEED);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not get response from server. Please try again.',
          timestamp: new Date().toISOString()
        }]);
        showToast('error', 'Failed to get response from server');
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const handleButtonClick = (e) => {
    if (isProcessing || isTyping) {
      cancelRequest();
    } else {
      handleSendMessage(e);
    }
  };

  const handleChatClick = (e, chatId) => {
    e.preventDefault();
    e.stopPropagation();
    loadChat(chatId);
  };

  // Filter chats based on search query
  const filteredChats = (chats) => {
    return chats.filter(chat => 
      chat.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      chat.messages.some(msg => 
        msg.text.toLowerCase().includes(searchQuery.toLowerCase())
      )
    );
  };

  return (
    <div className="d-flex vh-100">
      {/* Delete Confirmation Modal */}
      <div className={`modal fade ${showDeleteModal ? 'show' : ''}`} 
           style={{ display: showDeleteModal ? 'block' : 'none' }} 
           tabIndex="-1">
        <div className="modal-dialog modal-dialog-centered">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title">Confirm Deletion</h5>
              <button type="button" className="btn-close" onClick={() => setShowDeleteModal(false)}></button>
            </div>
            <div className="modal-body">
              <p>Are you sure you want to delete this chat? This action cannot be undone.</p>
            </div>
            <div className="modal-footer">
              <button type="button" className="btn btn-outline-secondary" onClick={() => setShowDeleteModal(false)}>Cancel</button>
              <button type="button" className="btn btn-danger" onClick={handleDelete}>
                <i className="bi bi-trash me-1"></i> Delete
              </button>
            </div>
          </div>
        </div>
      </div>
      {showDeleteModal && <div className="modal-backdrop fade show"></div>}

      {/* Rename Modal */}
      <div className={`modal fade ${showRenameModal ? 'show' : ''}`} 
           style={{ display: showRenameModal ? 'block' : 'none' }} 
           tabIndex="-1">
        <div className="modal-dialog modal-dialog-centered">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title">Rename Chat</h5>
              <button type="button" className="btn-close" onClick={() => setShowRenameModal(false)}></button>
            </div>
            <div className="modal-body">
              <input
                type="text"
                className="form-control"
                value={newChatTitle}
                onChange={(e) => setNewChatTitle(e.target.value)}
                placeholder="Enter new chat title"
                autoFocus
              />
            </div>
            <div className="modal-footer">
              <button type="button" className="btn btn-outline-secondary" onClick={() => setShowRenameModal(false)}>Cancel</button>
              <button type="button" className="btn btn-primary" onClick={handleRename}>
                <i className="bi bi-check2 me-1"></i> Save
              </button>
            </div>
          </div>
        </div>
      </div>
      {showRenameModal && <div className="modal-backdrop fade show"></div>}

      {/* Toast Notifications */}
      <div style={toastContainerStyle}>
        <div id="successToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-success text-white">
            <strong className="me-auto">Success</strong>
            <button type="button" className="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>

        <div id="errorToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-danger text-white">
            <strong className="me-auto">Error</strong>
            <button type="button" className="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>

        <div id="warningToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-warning text-dark">
            <strong className="me-auto">Warning</strong>
            <button type="button" className="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>

        <div id="infoToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-info text-white">
            <strong className="me-auto">Info</strong>
            <button type="button" className="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>
      </div>

      {/* Sidebar */}
      <div 
        ref={sidebarRef}
        className={`sidebar bg-white shadow-sm ${isSidebarVisible ? 'visible' : 'hidden'}`}
      >
        <div className="p-3 border-bottom">
          <button
            onClick={startNewChat}
            className="btn btn-outline-secondary w-70 d-flex align-items-center justify-content-center gap-2"
            disabled={isTyping || isProcessing}
          >
            <i className="bi bi-plus-lg"></i>
            <span>New Chat</span>
          </button>
        </div>
        
        <div className="p-3 border-bottom">
          <div className="input-group">
            <span className="input-group-text bg-white">
              <i className="bi bi-search"></i>
            </span>
            <input
              type="text"
              className="form-control"
              placeholder="Search chats..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
            {searchQuery && (
              <button
                className="btn btn-outline-secondary"
                type="button"
                onClick={() => setSearchQuery('')}
              >
                <i className="bi bi-x"></i>
              </button>
            )}
          </div>
        </div>
        
        <div className="p-3">
          <div className="d-flex justify-content-between align-items-center mb-2">
            <h6 className="text-muted mb-0">
              {showArchived ? 'Archived Chats' : 'Recent Chats'}
            </h6>
            <button 
              className="btn btn-sm btn-outline-secondary"
              onClick={() => setShowArchived(!showArchived)}
              title={showArchived ? 'Show active chats' : 'Show archived chats'}
            >
              {showArchived ? (
                <i className="bi bi-inbox"></i>
              ) : (
                <i className="bi bi-archive"></i>
              )}
            </button>
          </div>
          
          <div className="list-group list-group-flush chat-list">
            {filteredChats(showArchived ? archivedChats : chatHistory).length === 0 ? (
              <div className="text-muted p-3 text-center">
                <i className="bi bi-chat-square-text fs-4 mb-2 d-block"></i>
                No {showArchived ? 'archived' : 'active'} chats found
              </div>
            ) : (
              filteredChats(showArchived ? archivedChats : chatHistory)
                .sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
                .map(chat => (
                <div 
                  key={chat.id} 
                  className={`list-group-item list-group-item-action px-3 py-2 ${activeChat === chat.id ? 'active' : ''}`}
                  onClick={(e) => handleChatClick(e, chat.id)}
                >
                  <div className="d-flex justify-content-between align-items-start">
                    <div className="flex-grow-1 me-2" style={{ minWidth: 0 }}>
                      <div className="d-flex justify-content-between align-items-center">
                        <h6 
                          className="mb-0 text-truncate" 
                          style={{ maxWidth: '180px' }}
                          title={chat.title}
                        >
                          {chat.title}
                        </h6>
                        {chat.archivedAt && (
                          <span className="badge bg-secondary ms-2">Archived</span>
                        )}
                      </div>
                      <small className="text-muted">
                        {formatDate(chat.updatedAt || chat.createdAt)}
                      </small>
                    </div>

                    <div className="dropdown">
                      <button 
                        className="btn btn-sm btn-outline-secondary border-0 p-1"
                        type="button" 
                        data-bs-toggle="dropdown" 
                        aria-expanded="false"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <i className="bi bi-three-dots-vertical"></i>
                      </button>
                      <ul className="dropdown-menu dropdown-menu-end shadow-sm">
                        <li>
                          <button 
                            className="dropdown-item" 
                            onClick={(e) => {
                              e.preventDefault();
                              confirmRename(chat.id, chat.title);
                            }}
                          >
                            <i className="bi bi-pencil me-2"></i>Rename
                          </button>
                        </li>
                        <li>
                          <button 
                            className="dropdown-item" 
                            onClick={(e) => {
                              e.preventDefault();
                              handleShare(chat.id);
                            }}
                          >
                            <i className="bi bi-share me-2"></i>Share
                          </button>
                        </li>
                        {showArchived ? (
                          <li>
                            <button 
                              className="dropdown-item" 
                              onClick={(e) => {
                                e.preventDefault();
                                handleUnarchive(chat.id);
                              }}
                            >
                              <i className="bi bi-inbox me-2"></i>Unarchive
                            </button>
                          </li>
                        ) : (
                          <li>
                            <button 
                              className="dropdown-item" 
                              onClick={(e) => {
                                e.preventDefault();
                                handleArchive(chat.id);
                              }}
                            >
                              <i className="bi bi-archive me-2"></i>Archive
                            </button>
                          </li>
                        )}
                        <li><hr className="dropdown-divider" /></li>
                        <li>
                          <button 
                            className="dropdown-item text-danger" 
                            onClick={(e) => {
                              e.preventDefault();
                              confirmDelete(chat.id);
                            }}
                          >
                            <i className="bi bi-trash me-2"></i>Delete
                          </button>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className={`flex-grow-1 d-flex flex-column ${isSidebarVisible ? 'ms-sidebar' : ''}`}>
        {/* Header */}
        <header className="bg-primary text-white p-3 d-flex align-items-center justify-content-between sticky-top shadow-sm">
          <button 
            className="btn btn-light btn-sm me-2" 
            onClick={toggleSidebar}
            aria-label={isSidebarVisible ? 'Close sidebar' : 'Open sidebar'}
          >
            {isSidebarVisible ? (
              <i className="bi bi-x-lg"></i>
            ) : (
              <i className="bi bi-list"></i>
            )}
          </button>
          <h4 className="mb-0 fw-semibold text-truncate flex-grow-1 text-center">
            {[...chatHistory, ...archivedChats].find(c => c.id === activeChat)?.title || 'New Chat'}
          </h4>
          <div style={{ width: 40 }}></div>
        </header>

        {/* Messages Area */}
        <main className="flex-grow-1 overflow-auto p-3 bg-light">
          <div className="d-flex flex-column gap-3">
            {messages.length === 0 ? (
              <div className="text-center mt-5">
                <div className="mb-4">
                  <i className="bi bi-chat-square-text fs-1 text-muted"></i>
                </div>
                <h5 className="text-muted">Start a new conversation</h5>
                <p className="text-muted">Type a message below to begin chatting</p>
              </div>
            ) : (
              messages.map((msg) => (
                <div 
                  key={msg.id} 
                  className={`d-flex ${msg.sender === 'user' ? 'justify-content-end' : 'justify-content-start'}`}
                >
                  <div 
                    className={`message-container p-3 rounded-3 ${msg.sender === 'user' ? 'bg-primary text-white' : msg.type === 'typing' ? 'bg-white' : 'bg-white text-dark shadow-sm'}`}
                    style={{ maxWidth: '85%' }}
                  >
                    {msg.type === 'typing' ? (
                      <div className="d-flex align-items-center gap-2">
                        <div className="spinner-grow spinner-grow-sm text-secondary" role="status" />
                        <span className="text-muted">Thinking...</span>
                      </div>
                    ) : (
                      <div className="message-content">
                        {msg.sender === 'bot'
                          ? <div className="bot-message">{formatMessageContent(msg.text)}</div>
                          : <div className="user-message">{msg.text.split('\n').map((line, i) => <p key={i} className="mb-0">{line}</p>)}</div>
                        }
                      </div>
                    )}
                    <div className="text-end mt-1">
                      <small className={`text-opacity-75 ${msg.sender === 'user' ? 'text-white' : 'text-muted'}`}>
                        {new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                      </small>
                    </div>
                  </div>
                </div>
              ))
            )}
            <div ref={messagesEndRef} />
          </div>
        </main>

        {/* Input Area */}
        <footer className="p-3 border-top bg-white">
          <form onSubmit={handleSendMessage}>
            <div className="input-group">
              <input
                type="text"
                className="form-control rounded-pill ps-3 pe-5"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage(e);
                  }
                }}
                placeholder="Type your message..."
                ref={inputRef}
                disabled={isProcessing || isTyping}
                aria-label="Type your message"
              />
              <button
                type="button"
                className={`btn ms-2 rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping ? 'btn-secondary' : 'btn-secondary'}`}
                onClick={handleButtonClick}
                disabled={!inputValue.trim() && !(isProcessing || isTyping)}
              >
                {(isProcessing || isTyping) ? (
                  <span className="spinner-border spinner-border-sm text-light" role="status" />
                ) : 'Send'}
              </button>
            </div>
            <div className="text-center mt-2">
              <small className="text-muted">
                {isProcessing || isTyping ? (
                  <button 
                    type="button" 
                    className="btn btn-sm btn-outline-danger"
                    onClick={cancelRequest}
                  >
                    <i className="bi bi-stop-circle me-1"></i> Stop Generating
                  </button>
                ) : (
                  'Press Enter to send, Shift+Enter for new line'
                )}
              </small>
            </div>
          </form>
        </footer>
      </div>
    </div>
  );
}

export default Home;

const formatMessageContent = (text, type = 'text') => {
  if (!text) return null;

  if (type === 'image') {
    return (
      <div className="generated-image-container">
        <img
          src={`http://localhost:8000${text}`}
          alt="Generated content"
          className="img-fluid rounded"
          style={{ maxHeight: '300px', maxWidth: '100%' }}
          onError={e => {
            e.target.onerror = null;
            e.target.src = '/placeholder-image.png';
          }}
        />
      </div>
    );
  }

  // Markdown inline formatting
  const processText = content => {
    if (!content) return '';
    let processed = content.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    processed = processed.replace(/\*(.+?)\*/g, '<em>$1</em>');
    processed = processed.replace(/`(.+?)`/g, '<code class="inline-code">$1</code>');
    return processed;
  };

  // Parse the content into blocks
  const blocks = [];
  const lines = text.split('\n');
  let inCode = false;
  let codeLang = '';
  let codeLines = [];
  let textLines = [];

  const pushTextBlock = () => {
    if (textLines.length > 0) {
      blocks.push({
        type: 'text',
        content: textLines.join('\n'),
      });
      textLines = [];
    }
  };

  lines.forEach((line) => {
    if (line.startsWith('```')) {
      if (!inCode) {
        // Starting a code block
        pushTextBlock();
        inCode = true;
        codeLang = line.replace('```', '').trim();
        codeLines = [];
      } else {
        // Ending a code block
        inCode = false;
        blocks.push({
          type: 'code',
          lang: codeLang,
          content: codeLines.join('\n'),
        });
        codeLang = '';
        codeLines = [];
      }
    } else if (inCode) {
      codeLines.push(line);
    } else {
      textLines.push(line);
    }
  });

  // Push any remaining blocks after loop
  pushTextBlock();
  if (codeLines.length > 0) {
    blocks.push({
      type: 'code',
      lang: codeLang,
      content: codeLines.join('\n'),
    });
  }

  // Render blocks with proper keys
  return (
    <div className="message-content">
      {blocks.map((block, index) => {
        if (block.type === 'code') {
          return (
            <div key={`code-${index}`} className="code-block bg-dark text-light p-3 rounded mb-3">
              {block.lang && (
                <div className="text-muted mb-2 font-monospace small">{block.lang}</div>
              )}
              <pre className="m-0">
                <code className={`language-${block.lang || 'plaintext'}`}>
                  {block.content}
                </code>
              </pre>
            </div>
          );
        }

        // Process text blocks
        const paragraphs = block.content.split(/\n\s*\n/);
        return paragraphs
          .filter(p => p.trim())
          .map((paragraph, pIdx) => {
            const p = paragraph.trim();
            
            // Headings
            if (p.startsWith('### ')) {
              return (
                <h3
                  key={`h3-${index}-${pIdx}`}
                  className="message-heading"
                  dangerouslySetInnerHTML={{ __html: processText(p.replace(/^### /, '')) }}
                />
              );
            }
            if (p.startsWith('## ')) {
              return (
                <h2
                  key={`h2-${index}-${pIdx}`}
                  className="message-heading"
                  dangerouslySetInnerHTML={{ __html: processText(p.replace(/^## /, '')) }}
                />
              );
            }
            if (p.startsWith('# ')) {
              return (
                <h1
                  key={`h1-${index}-${pIdx}`}
                  className="message-heading"
                  dangerouslySetInnerHTML={{ __html: processText(p.replace(/^# /, '')) }}
                />
              );
            }

            // Lists
            if (p.startsWith('- ') || p.startsWith('* ')) {
              const items = p.split('\n');
              return (
                <ul key={`ul-${index}-${pIdx}`} className="message-list">
                  {items.map((item, i) => (
                    <li
                      key={`li-${i}`}
                      dangerouslySetInnerHTML={{
                        __html: processText(item.replace(/^[-*] /, ''))
                      }}
                    />
                  ))}
                </ul>
              );
            }
            
            if (/^\d+\.\s/.test(p)) {
              const items = p.split('\n');
              return (
                <ol key={`ol-${index}-${pIdx}`} className="message-list">
                  {items.map((item, i) => (
                    <li
                      key={`li-${i}`}
                      dangerouslySetInnerHTML={{
                        __html: processText(item.replace(/^\d+\.\s/, ''))
                      }}
                    />
                  ))}
                </ol>
              );
            }

            // Normal paragraph
            return (
              <p
                key={`p-${index}-${pIdx}`}
                className="message-paragraph"
                dangerouslySetInnerHTML={{ __html: processText(p) }}
              />
            );
          });
      })}
    </div>
  );
};

responder_service.py :

import requests
from datetime import datetime
from pymongo import MongoClient
from duckduckgo_search import DDGS
import base64
from bson.binary import Binary
from io import BytesIO
import uuid
from PIL import Image
from bson import ObjectId
import os
from tempfile import NamedTemporaryFile
from typing import Union
import tempfile
from services.utils import save_image
import bcrypt
from google.oauth2 import id_token
from google.auth.transport import requests as google_requests

# Configuration
GROQ_API_KEY = "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"
STABILITY_API_KEY = "sk-3UnY9eVsTHi0V0NCCa5mVY61FwL4djjKakG7V3ePqs9vorgi"
API_URL = "https://api.groq.com/openai/v1/chat/completions"
STABILITY_API_URL = (
    "https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image"
)

# MongoDB setup
client = MongoClient("mongodb://localhost:27017/")
db = client["ai_new"]


uploaded_images_collection = db["uploaded_images"]
users_collection = db["users"]

user_info_collection = db["user_info"] 

def get_generated_images_collection():
    return db["uploaded_images"]

def save_uploaded_image(image_data: Union[bytes, str], user_id: str) -> str:
    """Save uploaded image (either bytes or base64) and return file path"""
    try:
        # Create user-specific directory if it doesn't exist
        user_dir = os.path.join(IMAGE_UPLOAD_DIR, user_id)
        os.makedirs(user_dir, exist_ok=True)

        # Generate unique filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"upload_{timestamp}_{uuid.uuid4().hex[:8]}.png"
        filepath = os.path.join(user_dir, filename)

        # Handle both base64 and raw bytes
        if isinstance(image_data, str):
            # Assume it's base64 if it's a string
            if image_data.startswith("data:image"):
                # Strip data URL prefix if present
                image_data = image_data.split(",", 1)[1]
            image_bytes = base64.b64decode(image_data)
        else:
            image_bytes = image_data

        # Save the image
        with open(filepath, "wb") as f:
            f.write(image_bytes)

        return filepath
    except Exception as e:
        print(f"Error saving uploaded image: {e}")
        raise

def process_image_with_llm(
    image_paths: list[str], prompt: str = None, history: list = None
) -> str:
    print("📤 Sending multiple images to LLM with prompt:", prompt)

    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    # Encode images
    image_parts = [
        {
            "type": "image_url",
            "image_url": {
                "url": f"data:image/png;base64,{base64.b64encode(open(p, 'rb').read()).decode('utf-8')}"
            },
        }
        for p in image_paths
    ]

    # Convert previous text + image history
    llm_messages = []
    if history:
        for msg in history:
            if msg.get("is_image", False):
                llm_messages.append(
                    {
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg['prompt']}",
                    }
                )
                llm_messages.append(
                    {
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg['response'].replace('IMAGE:', '')}",
                    }
                )
            else:
                llm_messages.append({"role": "user", "content": msg["prompt"]})
                llm_messages.append({"role": "assistant", "content": msg["response"]})

    # Add current image + prompt
    llm_messages.append(
        {"role": "user", "content": [{"type": "text", "text": prompt}] + image_parts}
    )

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": llm_messages,
        "max_tokens": 1500,
    }

    try:
        print("⏳ Requesting LLM...")
        response = requests.post(API_URL, headers=headers, json=data, timeout=60)
        print("✅ Response status:", response.status_code)
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    except Exception as e:
        print(f"❌ Error in LLM call: {e}")
        raise

def signup_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            # Google Sign-In case
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())
                
                # Extract all available Google profile information
                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),  # Profile picture URL
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")  # Unique Google ID
                }

                # Check if user already exists
                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success", 
                        "message": "User already exists", 
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create comprehensive user document
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,  # Store all Google data
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }
                
                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success", 
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Normal signup case (unchanged)
            username = data.get("username")
            email = data.get("email")
            password = data.get("password")

            if not all([username, email, password]):
                return {"status": "error", "message": "Missing fields"}

            if user_info_collection.find_one({"email": email}):
                return {"status": "error", "message": "Email already registered"}
            
            user_doc = {
                "username": username,
                "email": email,
                "password": password,
                "auth_type": "manual",
                "created_at": datetime.utcnow(),
                "last_login": datetime.utcnow()
            }
            inserted = user_info_collection.insert_one(user_doc)
            return {"status": "success", "user_id": str(inserted.inserted_id)}

    except Exception as e:
        print(f"Signup error: {e}")
        return {"status": "error", "message": str(e)}
    
def login_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())

                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")
                }

                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success",
                        "message": "User already exists (logged in)",
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create account if not exist
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }

                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success",
                    "message": "New Google user created",
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Manual login
            email = data.get("email")
            password = data.get("password")

            if not all([email, password]):
                return {"status": "error", "message": "Missing fields"}

            user = user_info_collection.find_one({"email": email, "auth_type": "manual"})
            if not user:
                return {"status": "error", "message": "User not found"}

            if user["password"] != password:
                return {"status": "error", "message": "Incorrect password"}

            return {
                "status": "success",
                "message": "Login successful",
                "user_id": str(user["_id"]),
                "profile_data": {
                    "email": user["email"],
                    "username": user["username"],
                }
            }

    except Exception as e:
        return {"status": "error", "message": str(e)}

def handle_image_upload(image_data_list, user_id, chat_id, prompt=None):
    try:
        image_urls = []
        image_ids = []
        image_binaries = []
        temp_file_paths = []

        # Save and collect info
        for image_data in image_data_list:
            filename = save_image(image_data)
            image_url = f"/image/{filename}"
            image_urls.append(image_url)
            image_ids.append(str(uuid.uuid4()))
            image_binaries.append(Binary(image_data))

            # Save temp file for LLM
            with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp_file:
                tmp_file.write(image_data)
                temp_file_paths.append(tmp_file.name)

        # 🔥 Send to LLM with all image paths
        llm_response = None
        if prompt:
            history_messages = get_chat_history(user_id, chat_id)
            llm_response = process_image_with_llm(
                temp_file_paths, prompt, history=history_messages
            )

        # Clean up temp files
        for path in temp_file_paths:
            os.remove(path)

        # Save to DB
        image_doc = {
            "user_id": user_id,
            "chat_id": chat_id,
            "prompt": prompt,
            "image_data": image_binaries,
            "image_urls": image_urls,
            "image_ids": image_ids,
            "created_at": datetime.utcnow(),
        }

        inserted = uploaded_images_collection.insert_one(image_doc)
        document_id = str(inserted.inserted_id)

        # Message
        message = {
            "sender": "user",
            "type": "image-upload",
            "prompt": prompt or "",
            "image_urls": image_urls,
            "chat_id": chat_id,
            "user_id": user_id,
            "timestamp": datetime.utcnow(),
            "image_id": document_id,
            "llm_response": llm_response,
        }

        users_collection.update_one(
            {"_id": user_id},
            {"$push": {f"chats.{chat_id}.messages": message}},
            upsert=True,
        )

        chat = get_user_conversations_collection(user_id)

        chat.update_one(
            {"_id": user_id},
            {"$push": {f"chats.{chat_id}.messages": message}},
            upsert=True,
        )

        return {
            "status": "success",
            "image_ids": image_ids,
            "image_urls": image_urls,
            "message": "Images uploaded successfully",
            "llm_response": llm_response,
        }

    except Exception as e:
        print(f"Error in handle_image_upload (batch): {str(e)}")
        return {"status": "error", "error": str(e)}


def get_user_conversations_collection(user_id: str):
    """Get or create a conversations collection for a specific user"""
    return db[f"{user_id}"]

def users_info(user_id: str):
    chats_collection = get_user_conversations_collection(user_id)
    
    chat_docs = chats_collection.find({}, {"chat_id": 1, "title": 1, "created_at": 1})
    
    for chat in chat_docs:
        print("Chat ID:", chat.get("chat_id"))
        print("Title:", chat.get("title", "No title"))
        print("Created At:", chat.get("created_at"))
        print("-----")


def get_generated_images_collection():
    """Get the global generated images collection"""
    return db["generated_images"]


def search_web(query: str) -> str:
    print("Searching the web for: ", query)
    results = []
    with DDGS() as ddgs:
        for r in ddgs.text(query, max_results=10):
            snippet = f"{r['title']}: {r['body']}"
            results.append(snippet)
    return "\n".join(results)


def should_generate_image(prompt: str) -> bool:
    """Use the LLM to determine if the prompt is requesting an image generation"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the following user prompt to determine if the user is requesting an image to be generated.

    User Prompt: "{prompt}"

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.5,
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining image generation need: {e}")
        return False

def generate_image(prompt: str, user_id: str) -> dict:
    """Generate an image using Stability AI's API"""
    print(f"Generating image for prompt: {prompt}")
    
    headers = {
        "Authorization": f"Bearer {STABILITY_API_KEY}",
        "Content-Type": "application/json"
    }
    
    data = {
        "text_prompts": [{"text": prompt, "weight": 1}],
        "cfg_scale": 7,
        "height": 1024,
        "width": 1024,
        "samples": 1,
        "steps": 30,
    }
    
    try:
        response = requests.post(STABILITY_API_URL, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        response_data = response.json()
        
        if not response_data.get("artifacts"):
            raise Exception("No image artifacts in response")
            
        image_data = response_data["artifacts"][0]["base64"]
        image_bytes = base64.b64decode(image_data)
        
        # Save image information to the global images collection
        images_col = get_generated_images_collection()
        image_doc = {
            "user_id": user_id,
            "prompt": prompt,
            "generated_at": datetime.utcnow(),
            "model": "stable-diffusion-xl-1024-v1-0",
            "image_data": image_data  # Storing base64 for simplicity
        }
        image_id = images_col.insert_one(image_doc).inserted_id
        
        return {
            "type": "image",
            "image_bytes": image_bytes,
            "description": f"Generated image based on: '{prompt}'",
            "image_id": str(image_id)
        }
    except Exception as e:
        print(f"Image generation failed: {e}")
        raise

def should_perform_search(prompt: str, model_response: str) -> bool:
    """Determine if a web search is truly needed for this prompt"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the user's prompt and decide if a web search is ABSOLUTELY NECESSARY to answer correctly.
    Web search should ONLY be performed if:
    1. The question is about very recent events (last few days/weeks)
    2. The question requires real-time data (stock prices, sports scores, etc.)
    3. Your initial response indicates you don't know the answer
    4. The question is about specific facts not in your training data (after 2023)

    User Prompt: "{prompt}"
    Your Initial Response: "{model_response}"

    If any of the above conditions are met, respond with 'YES'.
    Otherwise, respond with 'NO'.

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.1,  # Lower temperature for more deterministic responses
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining search need: {e}")
        return False  # Default to no search if there's an error


def save_conversation(
    user_id: str,
    chat_id: str,
    prompt: str,
    response: str,
    title: str = None,
    is_image: bool = False,
):
    """Save conversation with title handling"""
    conversations_col = get_user_conversations_collection(user_id)

    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat:
        # New chat - use provided title or generate from prompt
        chat_title = (
            title
            if title
            else f"Chat: {prompt[:30]}..." if len(prompt) > 30 else f"Chat: {prompt}"
        )
        chat_doc = {
            "chat_id": chat_id,
            "user_id": user_id,
            "title": chat_title,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "messages": [],
        }
        conversations_col.insert_one(chat_doc)

    # Add message
    message = {
        "message_id": str(ObjectId()),
        "prompt": prompt,
        "response": response if not is_image else f"IMAGE:{response}",
        "is_image": is_image,
        "timestamp": datetime.utcnow(),
    }

    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$push": {"messages": message}, "$set": {"updated_at": datetime.utcnow()}},
    )

    print(f"Saved conversation for user {user_id} in chat {chat_id}")


def get_chat_history(user_id: str, chat_id: str, limit: int = 15):
    """Get the conversation history for a specific chat"""
    conversations_col = get_user_conversations_collection(user_id)
    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat or "messages" not in chat:
        return []

    # Return the most recent messages up to the limit
    return chat["messages"][-limit:]

def get_user_chats(user_id: str):
    conversations_col = get_user_conversations_collection(user_id)
    return list(
        conversations_col.find(
            {}, {"chat_id": 1, "title": 1, "created_at": 1, "updated_at": 1, "messages": 1}
        )
    )

def rename_chat(user_id: str, chat_id: str, new_title: str):
    """Rename a chat"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$set": {"title": new_title, "updated_at": datetime.utcnow()}},
    )


def delete_chat(user_id: str, chat_id: str):
    """Delete a chat and its messages"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.delete_one({"chat_id": chat_id})


def generate_response(
    prompt: str, user_id: str = "guest", chat_id: str = "default", title: str = None
):
    print(f"Processing prompt for user {user_id} in chat {chat_id}: {prompt}")
    
    users_info(user_id)

    try:
        # Image generation logic (same as before)
        if should_generate_image(prompt):
            try:
                image_result = generate_image(prompt, user_id)
                save_conversation(user_id, chat_id, prompt, image_result["image_id"], title=title, is_image=True)
                return image_result
            except Exception as e:
                return {
                    "type": "text",
                    "content": f"Failed to generate image. Error: {str(e)}"
                }
                
        # Normal text response flow
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        history_messages = get_chat_history(user_id, chat_id)

        # Prepare the message history for the LLM
        llm_messages = []
        for msg in history_messages:
            if msg.get("is_image", False):
                llm_messages.append(
                    {
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg['prompt']}",
                    }
                )
                llm_messages.append(
                    {
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg['response'].replace('IMAGE:', '')}",
                    }
                )
            else:
                llm_messages.append({"role": "user", "content": msg["prompt"]})
                llm_messages.append({"role": "assistant", "content": msg["response"]})

        # Add the current prompt with instruction to be confident
        llm_messages.append(
            {
                "role": "user",
                "content": f"{prompt}\n\nAnswer confidently using your knowledge. Only say you don't know if you're absolutely unsure.",
            }
        )

        initial_data = {
            "model": "meta-llama/llama-4-scout-17b-16e-instruct",
            "messages": llm_messages,
            "temperature": 0.3,
            "max_tokens": 2048,
        }

        initial_response = requests.post(
            API_URL, headers=headers, json=initial_data, timeout=30
        )
        initial_response.raise_for_status()
        initial_result = initial_response.json()
        initial_reply = initial_result["choices"][0]["message"]["content"]

        # Only consider web search if the response indicates uncertainty
        uncertain_keywords = [
            "I don't know",
            "I'm not sure",
            "I don't have information",
            "my knowledge is limited",
            "as of my last update",
        ]

        is_uncertain = any(
            keyword.lower() in initial_reply.lower() for keyword in uncertain_keywords
        )

        if is_uncertain and should_perform_search(prompt, initial_reply):
            web_data = search_web(prompt)
            enhanced_prompt = f"""{prompt}
            
            [Additional Context from Web Search]:
            {web_data}
            
            Please use this additional information to provide a better answer. 
            If the information contradicts your knowledge, prioritize the web search results 
            only if they're clearly about recent events (after 2023)."""
            
            enhanced_history = llm_messages.copy()
            enhanced_history[-1]["content"] = enhanced_prompt

            enhanced_response = requests.post(
                API_URL,
                headers=headers,
                json={
                    "model": "meta-llama/llama-4-scout-17b-16e-instruct",
                    "messages": enhanced_history,
                    "temperature": 0.3,
                    "max_tokens": 2048,
                },
                timeout=30,
            )
            enhanced_response.raise_for_status()
            final_reply = enhanced_response.json()["choices"][0]["message"]["content"]
        else:
            final_reply = initial_reply

        save_conversation(user_id, chat_id, prompt, final_reply, title=title)
        return {"type": "text", "content": final_reply}

    except Exception as e:
        print(f"Error in text generation: {e}")
        return {"type": "text", "content": f"Sorry, I encountered an error: {str(e)}"}

main.py :

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel,EmailStr
from services.responder_service import generate_response, rename_chat, delete_chat, get_user_chats, get_chat_history,handle_image_upload,signup_user,login_user
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import base64
import os
from datetime import datetime
import uuid
from fastapi import UploadFile, File, Form
from typing import Annotated
from fastapi.staticfiles import StaticFiles
from typing import Optional,List

app = FastAPI()

# Create image directory if it doesn't exist
os.makedirs("image", exist_ok=True)

# Serve static files from the image directory
app.mount("/image", StaticFiles(directory="image"), name="images")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class PromptRequest(BaseModel):
    prompt: str
    user_id: str
    chat_id: str
    title: Optional[str] = None

class ChatRenameRequest(BaseModel):
    user_id: str
    chat_id: str
    new_title: str

class ChatDeleteRequest(BaseModel):
    user_id: str
    chat_id: str

class ChatHistoryRequest(BaseModel):
    user_id: str
    chat_id: str
    limit: Optional[int] = 20
    
class ImagePromptRequest(BaseModel):
    prompt: Optional[str] = None
    user_id: str
    chat_id: str

class ManualSignupRequest(BaseModel):
    username: str
    email: EmailStr
    password: str

class GoogleSignupRequest(BaseModel):
    token: str  # Google ID token

class ManualLoginRequest(BaseModel):
    email: EmailStr
    password: str

class GoogleLoginRequest(BaseModel):
    token: str

@app.post("/login")
async def login_manual(request: ManualLoginRequest):
    result = login_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=401, detail=result["message"])


@app.post("/login/google")
async def login_google(request: GoogleLoginRequest):
    result = login_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse({
            "access_token": "dummy_token",  # optional: JWT later
            "user_data": result
        })
    else:
        raise HTTPException(status_code=401, detail=result["message"])
    
@app.post("/signup")
async def signup_manual(request: ManualSignupRequest):
    result = signup_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])

@app.post("/signup/google")
async def signup_google(request: GoogleSignupRequest):
    result = signup_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])
    
@app.post("/upload-image")
async def upload_image(
    images: List[UploadFile] = File(...),
    user_id: str = Form(...),
    chat_id: str = Form(...),
    prompt: Optional[str] = Form(None),
):
    try:
        image_data_list = []
        for image in images:
            image_data = await image.read()
            image_data_list.append(image_data)

        result = handle_image_upload(
            image_data_list=image_data_list,
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt
        )

        return JSONResponse({
            "status": "success",
            "image_ids": result.get("image_ids", []),
            "image_urls": result.get("image_urls", []),
            "llm_responses": [result.get("llm_response", "")]
        })

    except Exception as e:
        import traceback
        print("Upload image error traceback:", traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

def save_image(image_bytes: bytes) -> str:
    """Save image to /image folder and return filename"""
    filename = f"img_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:4]}.png"
    filepath = os.path.join("image", filename)
    
    with open(filepath, "wb") as f:
        f.write(image_bytes)
    
    return filename

@app.post("/chat")
async def chat(request: PromptRequest):
    try:
        response = generate_response(
            prompt=request.prompt,
            user_id=request.user_id,
            chat_id=request.chat_id,
            title=request.title
        )
        
        if response.get("type") == "image":
            if response.get("error") == "rate_limit":
                return JSONResponse({
                    "type": "text",
                    "content": "I'm getting rate limited by the image generation service. Please try again in a little while."
                })
            
            filename = save_image(response["image_bytes"])
            image_url = f"/image/{filename}"
            
            return JSONResponse({
                "type": "image",
                "image_url": image_url,
                "description": response.get("description", "Generated image"),
                "image_id": response.get("image_id", "")
            })
        else:
            return JSONResponse({
                "type": "text",
                "content": response["content"]
            })
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/rename-chat")
async def rename_chat_endpoint(request: ChatRenameRequest):
    try:
        rename_chat(request.user_id, request.chat_id, request.new_title)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/delete-chat")
async def delete_chat_endpoint(request: ChatDeleteRequest):
    try:
        delete_chat(request.user_id, request.chat_id)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/get_user_chats/{user_id}")
def get_user_chats_endpoint(user_id: str):
    try:
        chats = get_user_chats(user_id)

        # Convert Mongo ObjectId and datetime to JSON serializable
        for chat in chats:
            if "_id" in chat:
                chat["_id"] = str(chat["_id"])
            if "created_at" in chat:
                chat["created_at"] = chat["created_at"].isoformat()
            if "updated_at" in chat:
                chat["updated_at"] = chat["updated_at"].isoformat()
            if "messages" in chat:
                for message in chat["messages"]:
                    if "timestamp" in message and isinstance(message["timestamp"], datetime):
                        message["timestamp"] = message["timestamp"].isoformat()
        
        return JSONResponse(content={"chats": chats}, status_code=200)
    except Exception as e:
        print("💥 Error in get_user_chats_endpoint:", e)
        return JSONResponse(content={"detail": "Failed to fetch chats"}, status_code=500)

@app.post("/get_chat_history")
async def get_chat_history_endpoint(request: ChatHistoryRequest):
    try:
        history = get_chat_history(request.user_id, request.chat_id, request.limit)
        return JSONResponse({"history": history})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

Home.jsx :

import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import './home.css';
import 'bootstrap-icons/font/bootstrap-icons.css';
import '@fortawesome/fontawesome-free/css/all.min.css';
import { toast, ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

function Home() {
  // State management
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatHistory, setChatHistory] = useState([]);
  const [archivedChats, setArchivedChats] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [isSidebarVisible, setIsSidebarVisible] = useState(true);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [chatToDelete, setChatToDelete] = useState(null);
  const [showArchived, setShowArchived] = useState(false);
  const [showRenameModal, setShowRenameModal] = useState(false);
  const [newChatTitle, setNewChatTitle] = useState('');
  const [chatToRename, setChatToRename] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [copiedMessageId, setCopiedMessageId] = useState(null);
  const [regeneratingMessageId, setRegeneratingMessageId] = useState(null);
  const [copiedCodeId, setCopiedCodeId] = useState(null);
  const [downloadedCodeId, setDownloadedCodeId] = useState(null);
  const [selectedImages, setSelectedImages] = useState([]);
  const [isUploadingImages, setIsUploadingImages] = useState(false);
  const [editingChatId, setEditingChatId] = useState(null);
  const [tempTitle, setTempTitle] = useState('');
  const [renameSource, setRenameSource] = useState(null);
  const [showSearchModal, setShowSearchModal] = useState(false);

  // Refs
  const messagesEndRef = useRef(null);
  const userId = useRef("user_" + Math.random().toString(36).substr(2, 9));
  const typingIntervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const botMessageIdRef = useRef(null);
  const inputRef = useRef(null);
  const sidebarRef = useRef(null);
  const typingMessageId = useRef(null);
  const fileInputRef = useRef(null);
  const renameInputRef = useRef(null);
  const renameFormRef = useRef(null);
  const chatInputRef = useRef(null);
  const searchInputRef = useRef(null);
  const [chats, setChats] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const user = JSON.parse(localStorage.getItem('user'));
  const user_id = user?.user_id;

  const TYPING_SPEED = 20; // milliseconds per character
  const MAX_IMAGES = 10;

  // Generate unique ID for messages
  const generateUniqueId = () => `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  // Effects
  useEffect(() => {
    // Cleanup on unmount
    return () => {
      if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
      // Clean up object URLs
      selectedImages.forEach(img => URL.revokeObjectURL(img.preview));
    };
  }, [selectedImages]);

  useEffect(() => {
    if (inputValue === '' && inputRef.current) {
      inputRef.current.style.height = 'auto';
    }
  }, [inputValue]);

  useEffect(() => {
    // Scroll to bottom when messages change
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    // Focus input when not processing
    if (!isProcessing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isProcessing]);

  useEffect(() => {
    if (chatHistory.length === 0) {
      const defaultChat = {
        id: generateUniqueId(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory([defaultChat]);
      setActiveChat(defaultChat.id);
    }
  }, []);

  useEffect(() => {
    // Close sidebar when clicking outside
    const handleClickOutside = (event) => {
      if (sidebarRef.current && !sidebarRef.current.contains(event.target)) {
        if (window.innerWidth < 768) {
          setIsSidebarVisible(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  useEffect(() => {
    const fetchChats = async () => {
      try {
        const res = await fetch(`http://localhost:8000/get_user_chats/${user_id}`);
        if (!res.ok) {
          const errData = await res.json();
          throw new Error(errData.detail || "Server error");
        }
        const data = await res.json();
        setChats(data.chats);
        console.log(data.chats)
        data.chats.forEach((c, i) => console.log(`Chat ${i + 1} Title:`, c.title));

      } catch (err) {
        setError(err.message || "Error fetching chats");
      } finally {
        setLoading(false);
      }
    };

    if (user_id) fetchChats();
  }, [user_id]);

  if (!user_id) return <p className="text-red-500">User not logged in.</p>;
  if (loading) return <p>Loading chats...</p>;
  if (error) return <p className="text-red-500">{error}</p>;

  // Image handling functions
  const handleImageUpload = (e) => {
    const files = Array.from(e.target.files);

    const validTypes = ['image/jpeg', 'image/png', 'image/webp'];
    const invalidFiles = files.filter(f => !validTypes.includes(f.type));
    if (invalidFiles.length > 0) {
      toast.error(`Invalid file type: ${invalidFiles.map(f => f.name).join(', ')}`);
      return;
    }

    const maxSize = 5 * 1024 * 1024;
    const oversizedFiles = files.filter(f => f.size > maxSize);
    if (oversizedFiles.length > 0) {
      toast.error(`Files too large (max 5MB): ${oversizedFiles.map(f => f.name).join(', ')}`);
      return;
    }

    if (files.length + selectedImages.length > MAX_IMAGES) {
      toast.warn(`You can upload maximum ${MAX_IMAGES} images`);
      return;
    }

    const newImages = files.map(file => ({
      file,
      id: generateUniqueId(),
      preview: URL.createObjectURL(file)   // 👈 preview for local display only
    }));

    setSelectedImages(prev => [...prev, ...newImages]);

    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // In your removeImage function
  const removeImage = (id) => {
    const imageToRemove = selectedImages.find(img => img.id === id);
    if (imageToRemove?.preview?.startsWith('blob:')) {
      URL.revokeObjectURL(imageToRemove.preview);
    }
    setSelectedImages(prev => prev.filter(img => img.id !== id));
  };

  const clearSelectedImages = () => {
    selectedImages.forEach(img => {
      if (img.preview?.startsWith('blob:')) {
        URL.revokeObjectURL(img.preview);
      }
    });
    setSelectedImages([]);
  };

  const uploadImages = async () => {
    if (selectedImages.length === 0) return null;

    setIsUploadingImages(true);
    try {
      const formData = new FormData();
      selectedImages.forEach((image) => {
        formData.append('images', image.file);
      });

      formData.append('user_id', user_id || userId.current);
      formData.append('chat_id', activeChat || 'default');
      if (inputValue.trim()) {
        formData.append('prompt', inputValue.trim());
      }

      const response = await fetch('http://localhost:8000/upload-image', {
        method: 'POST',
        body: formData,
      });

      const result = await response.json();

      if (!response.ok || result.status === 'error') {
        throw new Error(result.error || 'Failed to upload images');
      }

      return result;
    } catch (error) {
      console.error('Error uploading images:', error);
      toast.error(error.message || 'Failed to upload images');
      return null;
    } finally {
      setIsUploadingImages(false);
    }
  };

  // Chat operations
  const generateChatTitle = (messages) => {
    const firstUserMessage = messages.find(msg => msg.sender === 'user');
    if (firstUserMessage) {
      const shortText = firstUserMessage.text
        .replace(/\n/g, ' ')
        .trim()
        .slice(0, 30);
      return shortText + (firstUserMessage.text.length > 30 ? '...' : '');
    }
    return `New Chat ${new Date().toLocaleTimeString()}`;
  };

  const handleCopy = (text, id) => {
    navigator.clipboard.writeText(text);
    setCopiedMessageId(id);
    setTimeout(() => setCopiedMessageId(null), 1000);
  };

  const handleRegenerate = (id) => {
    setRegeneratingMessageId(id);
    regenerateResponse(id);
    setTimeout(() => setRegeneratingMessageId(null), 1000);
  };

  const handleCopyCode = (content, id) => {
    navigator.clipboard.writeText(content);
    setCopiedCodeId(id);
    setTimeout(() => setCopiedCodeId(null), 1000);
  };

  const handleDownloadCode = (content, lang, id) => {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `code-${lang || 'snippet'}.${lang || 'txt'}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setDownloadedCodeId(id);
    setTimeout(() => setDownloadedCodeId(null), 1000);
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
    });
  };

  const toggleSidebar = () => setIsSidebarVisible(!isSidebarVisible);

  const cancelRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);

    if (typingMessageId.current) {
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId.current));
      typingMessageId.current = null;
    }

    botMessageIdRef.current = null;
    typingMessageId.current = null;
    setIsProcessing(false);
    setIsTyping(false);
    setMessages(prev => prev.filter(msg => msg.id !== typingMessageId.current));
  };

  const startNewChat = () => {
    if (isTyping || isProcessing) return;

    const emptyChat = chatHistory.find(chat => chat.messages.length === 0);
    if (emptyChat) {
      setActiveChat(emptyChat.id);
      setMessages([]);
    } else {
      const currentChat = chatHistory.find(chat => chat.id === activeChat);
      const hasBotMessage = messages.some(msg => msg.sender === 'bot');

      if (currentChat && hasBotMessage) {
        const updatedChat = {
          ...currentChat,
          messages: [...messages],
          title: currentChat.title === 'New Chat' ? generateChatTitle(messages) : currentChat.title,
          updatedAt: new Date().toISOString()
        };

        const updatedHistory = chatHistory.map(chat =>
          chat.id === activeChat ? updatedChat : chat
        );
        setChatHistory(updatedHistory);
      }

      const newChat = {
        id: generateUniqueId(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory(prev => [newChat, ...prev]);
      setMessages([]);
      setActiveChat(newChat.id);
    }
  };

  const loadChat = (chatId) => {
    const chat = [...chatHistory, ...archivedChats].find(c => c.id === chatId);
    if (chat) {
      setMessages(chat.messages);
      setActiveChat(chatId);

      if (window.innerWidth < 768) {
        setIsSidebarVisible(false);
      }
    }
  };

  const handleShare = async (chatId) => {
    const chat = [...chatHistory, ...archivedChats].find(c => c.id === chatId);
    if (!chat) return;

    try {
      const content = chat.messages.map(msg =>
        `${msg.sender === 'user' ? 'You' : 'Assistant'}: ${msg.text}`
      ).join('\n\n');

      await navigator.clipboard.writeText(content);
    } catch (err) {
      toast.error("Failed to copy chat");
      console.error('Failed to copy chat:', err);
    }
  };

  const handleArchive = (chatId) => {
    const chat = chatHistory.find(c => c.id === chatId);
    if (!chat) return;

    setArchivedChats(prev => [{
      ...chat,
      archivedAt: new Date().toISOString()
    }, ...prev]);
    setChatHistory(prev => prev.filter(c => c.id !== chatId));

    if (activeChat === chatId) {
      setMessages([]);
      setActiveChat(null);
    }
  };

  const handleUnarchive = (chatId) => {
    const chat = archivedChats.find(c => c.id === chatId);
    if (!chat) return;

    setChatHistory(prev => [{
      ...chat,
      archivedAt: undefined
    }, ...prev]);
    setArchivedChats(prev => prev.filter(c => c.id !== chatId));
  };

  const confirmDelete = (chatId) => {
    setChatToDelete(chatId);
    setShowDeleteModal(true);
  };

  const handleDelete = async () => {
    if (!chatToDelete) return;

    try {
      const response = await fetch('http://localhost:8000/delete-chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          user_id: user_id || userId.current,
          chat_id: chatToDelete,
        }),
      });
    } catch (error) {
      console.error('Error deleting chat:', error);
      toast.error("Failed to delete chat");
      return;
    }
    const updatedHistory = chatHistory.filter(chat => chat.id !== chatToDelete);
    const updatedArchived = archivedChats.filter(chat => chat.id !== chatToDelete);

    setChatHistory(updatedHistory);
    setArchivedChats(updatedArchived);

    if (activeChat === chatToDelete) {
      setMessages([]);
      setActiveChat(null);
    }

    setShowDeleteModal(false);
    setChatToDelete(null);
    toast.success("Chat deleted!");
  };

  const confirmRename = (chatId, currentTitle) => {
    setChatToRename(chatId);
    setNewChatTitle(currentTitle);
    setShowRenameModal(true);
  };

  const handleRenameInline = async (chatId) => {
    if (!tempTitle.trim()) {
      setEditingChatId(null);
      setTempTitle('');
      setRenameSource(null);
      return;
    }

    try {
      // Update local state
      setChatHistory(prev =>
        prev.map(chat =>
          chat.id === chatId
            ? { ...chat, title: tempTitle.trim(), updatedAt: new Date().toISOString() }
            : chat
        )
      );

      setArchivedChats(prev =>
        prev.map(chat =>
          chat.id === chatId
            ? { ...chat, title: tempTitle.trim(), updatedAt: new Date().toISOString() }
            : chat
        )
      );

      // API call
      await fetch('http://localhost:8000/rename-chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          user_id: user_id || userId.current,
          chat_id: chatId,
          new_title: tempTitle.trim(),
        }),
      });

    } catch (err) {
      console.error('Rename failed:', err);
      toast.error("Rename failed");
    }

    setEditingChatId(null);
    setTempTitle('');
    setRenameSource(null);
  };

  const updateChatHistory = (userMessage, botMessage, title) => {
    if (!activeChat) {
      const newChat = {
        id: generateUniqueId(),
        title,
        messages: [userMessage, botMessage],
        createdAt: new Date().toISOString()
      };
      setChatHistory(prev => [newChat, ...prev]);
      setActiveChat(newChat.id);
    } else {
      setChatHistory(prev =>
        prev.map(chat =>
          chat.id === activeChat
            ? {
              ...chat,
              title: chat.title === 'New Chat' ? title : chat.title,
              messages: [...chat.messages, userMessage, botMessage],
              updatedAt: new Date().toISOString()
            }
            : chat
        )
      );
    }
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if ((!inputValue.trim() && selectedImages.length === 0) || isProcessing) return;

    const userMessageText = inputValue.trim() || (selectedImages.length > 0 ? "Analyze these images" : "");
    if (!userMessageText) return;

    const userMessage = {
      id: generateUniqueId(),
      text: userMessageText,
      type: selectedImages.length > 0 ? 'image-upload' : 'text',
      sender: 'user',
      timestamp: new Date().toISOString(),
      images: selectedImages.map(img => img.preview) || 'no image'
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInputValue('');

    if (selectedImages.length > 0) {
      clearSelectedImages();
    }

    if (inputRef.current) {
      inputRef.current.style.height = 'auto';
    }

    setIsProcessing(true);
    setIsTyping(true);

    const typingMessageId = generateUniqueId();
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: '',
      timestamp: new Date().toISOString()
    }]);

    abortControllerRef.current = new AbortController();
    const title = generateChatTitle([userMessage]);

    try {
      let response;

      if (selectedImages.length > 0) {
        const uploadResponse = await uploadImages();

        if (!uploadResponse) throw new Error('Image upload failed');

        userMessage.image_urls = uploadResponse.image_urls;

        const imageResponses = uploadResponse.llm_responses;
        const responseText = imageResponses && imageResponses.length > 0
          ? imageResponses[0]
          : "Image processed.";

        const botMessageId = generateUniqueId();
        botMessageIdRef.current = botMessageId;

        setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));
        setMessages(prev => [...prev, {
          id: botMessageId,
          type: 'text',
          sender: 'bot',
          text: '',
          timestamp: new Date().toISOString()
        }]);

        let currentIndex = 0;
        typingIntervalRef.current = setInterval(() => {
          if (currentIndex < responseText.length) {
            setMessages(prev =>
              prev.map(msg =>
                msg.id === botMessageId
                  ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                  : msg
              )
            );
            currentIndex++;
          } else {
            clearInterval(typingIntervalRef.current);
            typingIntervalRef.current = null;
            botMessageIdRef.current = null;
            setIsTyping(false);

            const finalMessage = {
              id: botMessageId,
              type: 'text',
              sender: 'bot',
              text: responseText,
              timestamp: new Date().toISOString()
            };

            updateChatHistory(userMessage, finalMessage, title);
            clearSelectedImages(); // ✅ clear here
          }
        }, TYPING_SPEED);

        return;
      }
      // ✅ Handle normal text message
      response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          prompt: userMessageText,
          user_id: user_id || userId.current,
          chat_id: activeChat,
          title: title || 'New Chat',
        }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }

      const data = await response.json();

      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      if (data.type === "image") {
        const botMessage = {
          id: generateUniqueId(),
          type: 'image',
          sender: 'bot',
          text: data.description || "Generated image",
          image_url: data.image_url,
          timestamp: new Date().toISOString()
        };

        setMessages(prev => [...prev, botMessage]);
        updateChatHistory(userMessage, botMessage, title);

        setIsProcessing(false);
        setIsTyping(false);
        if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
        if (abortControllerRef.current) abortControllerRef.current = null;
      } else {
        const responseText = data.content || JSON.stringify(data);
        const botMessageId = generateUniqueId();
        botMessageIdRef.current = botMessageId;

        setMessages(prev => [...prev, {
          id: botMessageId,
          type: 'text',
          sender: 'bot',
          text: '',
          timestamp: new Date().toISOString()
        }]);

        let currentIndex = 0;
        typingIntervalRef.current = setInterval(() => {
          if (currentIndex < responseText.length) {
            setMessages(prev =>
              prev.map(msg =>
                msg.id === botMessageId
                  ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                  : msg
              )
            );
            currentIndex++;
          } else {
            clearInterval(typingIntervalRef.current);
            typingIntervalRef.current = null;
            botMessageIdRef.current = null;
            setIsTyping(false);

            const finalMessage = {
              id: botMessageId,
              type: 'text',
              sender: 'bot',
              text: responseText,
              timestamp: new Date().toISOString()
            };

            updateChatHistory(userMessage, finalMessage, title);
            clearSelectedImages(); // ✅ clear here if any
          }
        }, TYPING_SPEED);
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: generateUniqueId(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not get response from server. Please try again.',
          timestamp: new Date().toISOString()
        }]);
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const regenerateResponse = async (messageId) => {
    const messageToRegenerate = messages.find(msg => msg.id === messageId);
    if (!messageToRegenerate || messageToRegenerate.sender !== 'bot') return;

    // Find the previous user message that triggered this bot response
    const messageIndex = messages.findIndex(msg => msg.id === messageId);
    const previousUserMessage = messages[messageIndex - 1];

    if (!previousUserMessage || previousUserMessage.sender !== 'user') return;

    // Remove the old bot response
    setMessages(prev => prev.filter(msg => msg.id !== messageId));

    // Create new typing indicator
    const typingMessageId = generateUniqueId();
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: '',
      timestamp: new Date().toISOString()
    }]);

    setIsProcessing(true);
    setIsTyping(true);
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          prompt: previousUserMessage.text,
          user_id: user_id || userId.current,
          chat_id: activeChat,
          title: [...chatHistory, ...archivedChats].find(c => c.id === activeChat)?.title || 'New Chat',
        }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) throw new Error(`Server error: ${response.status}`);

      const data = await response.json();
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      if (data.type === "image") {
        const botMessage = {
          id: generateUniqueId(),
          type: 'image',
          sender: 'bot',
          text: data.description || "Generated image",
          image_url: data.image_url,
          timestamp: new Date().toISOString()
        };
        setMessages(prev => [...prev, botMessage]);

        setIsProcessing(false);
        setIsTyping(false);
        if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
        if (abortControllerRef.current) abortControllerRef.current = null;
      } else {
        const responseText = data.content || JSON.stringify(data);
        const botMessageId = generateUniqueId();

        // Typing effect for the new response
        let currentIndex = 0;
        typingIntervalRef.current = setInterval(() => {
          if (currentIndex < responseText.length) {
            setMessages(prev =>
              prev.map(msg =>
                msg.id === botMessageId
                  ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                  : msg
              )
            );
            currentIndex++;
          } else {
            clearInterval(typingIntervalRef.current);
            typingIntervalRef.current = null;
            setIsTyping(false);
          }
        }, TYPING_SPEED);

        setMessages(prev => [...prev, {
          id: botMessageId,
          type: 'text',
          sender: 'bot',
          text: '',
          timestamp: new Date().toISOString()
        }]);
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: generateUniqueId(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not regenerate response. Please try again.',
          timestamp: new Date().toISOString()
        }]);
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const formatMessageContent = (text, type = 'text') => {
    if (!text) return null;

    if (type === 'image') {
      return (
        <div className="generated-image-container">
          <img
            src={`http://localhost:8000${text}`}
            alt="Generated content"
            className="img-fluid rounded"
            style={{ maxHeight: '300px', maxWidth: '100%' }}
            onError={e => {
              e.target.onerror = null;
              e.target.src = '/placeholder-image.png';
            }}
          />
        </div>
      );
    }

    // Markdown inline formatting
    const processText = content => {
      if (!content) return '';
      let processed = content.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      processed = processed.replace(/\*(.+?)\*/g, '<em>$1</em>');
      processed = processed.replace(/`(.+?)`/g, '<code class="inline-code">$1</code>');
      return processed;
    };

    // Parse the content into blocks
    const blocks = [];
    const lines = text.split('\n');
    let inCode = false;
    let codeLang = '';
    let codeLines = [];
    let textLines = [];

    const pushTextBlock = () => {
      if (textLines.length > 0) {
        blocks.push({
          type: 'text',
          content: textLines.join('\n'),
        });
        textLines = [];
      }
    };

    lines.forEach((line) => {
      if (line.startsWith('```')) {
        if (!inCode) {
          // Starting a code block
          pushTextBlock();
          inCode = true;
          codeLang = line.replace('```', '').trim();
          codeLines = [];
        } else {
          // Ending a code block
          inCode = false;
          blocks.push({
            type: 'code',
            lang: codeLang,
            content: codeLines.join('\n'),
          });
          codeLang = '';
          codeLines = [];
        }
      } else if (inCode) {
        codeLines.push(line);
      } else {
        textLines.push(line);
      }
    });

    // Push any remaining blocks after loop
    pushTextBlock();
    if (codeLines.length > 0) {
      blocks.push({
        type: 'code',
        lang: codeLang,
        content: codeLines.join('\n'),
      });
    }

    // Render blocks with proper keys
    return (
      <div className="message-content">
        {blocks.map((block, index) => {
          if (block.type === 'code') {
            return (
              <div key={`code-${index}`} className="code-block-container position-relative mb-3">
                <div className="code-block bg-dark text-light p-3 rounded">
                  {block.lang && (
                    <div className="text-muted mb-2 font-monospace small">{block.lang}</div>
                  )}
                  <pre className="m-0">
                    <code className={`language-${block.lang || 'plaintext'}`}>
                      {block.content}
                    </code>
                  </pre>
                </div>
                <div className="code-actions position-absolute top-0 end-0 p-2 d-flex gap-1">
                  <button
                    className="btn btn-sm buttonn1"
                    onClick={() => handleCopyCode(block.content, block.id)}
                    title="Copy code"
                  >
                    <i className={copiedCodeId === block.id ? "bi bi-clipboard-check" : "bi bi-copy"}></i>
                    <span>
                      {copiedCodeId === block.id ? "  Copied" : "  Copy"}
                    </span>
                  </button>
                  <button
                    className="btn btn-sm buttonn1"
                    onClick={() => handleDownloadCode(block.content, block.lang, block.id)}
                    title="Download code"
                  >
                    <i className={downloadedCodeId === block.id ? "bi bi-check-square" : "bi bi-download"}></i>
                    <span>
                      {downloadedCodeId === block.id ? "  Downloaded" : "  Download"}
                    </span>
                  </button>
                </div>
              </div>
            );
          }

          // Process text blocks
          const paragraphs = block.content.split(/\n\s*\n/);
          return paragraphs
            .filter(p => p.trim())
            .map((paragraph, pIdx) => {
              const p = paragraph.trim();

              // Headings
              if (p.startsWith('### ')) {
                return (
                  <h1
                    key={`h1-${index}-${pIdx}`}
                    className="message-heading"
                    dangerouslySetInnerHTML={{ __html: processText(p.replace(/^### /, '')) }}
                  />
                );
              }
              if (p.startsWith('## ')) {
                return (
                  <h3
                    key={`h3-${index}-${pIdx}`}
                    className="message-heading"
                    dangerouslySetInnerHTML={{ __html: processText(p.replace(/^## /, '')) }}
                  />
                );
              }
              if (p.startsWith('# ')) {
                return (
                  <h3
                    key={`h3-${index}-${pIdx}`}
                    className="message-heading"
                    dangerouslySetInnerHTML={{ __html: processText(p.replace(/^# /, '')) }}
                  />
                );
              }

              // Lists
              if (p.startsWith('- ') || p.startsWith('* ')) {
                const items = p.split('\n');
                return (
                  <ul key={`ul-${index}-${pIdx}`} className="message-list">
                    {items.map((item, i) => (
                      <li
                        key={`li-${i}`}
                        dangerouslySetInnerHTML={{
                          __html: processText(item.replace(/^[-*] /, ''))
                        }}
                      />
                    ))}
                  </ul>
                );
              }

              if (/^\d+\.\s/.test(p)) {
                const items = p.split('\n');
                return (
                  <ol key={`ol-${index}-${pIdx}`} className="message-list">
                    {items.map((item, i) => (
                      <li
                        key={`li-${i}`}
                        dangerouslySetInnerHTML={{
                          __html: processText(item.replace(/^\d+\.\s/, ''))
                        }}
                      />
                    ))}
                  </ol>
                );
              }

              // Normal paragraph
              return (
                <p
                  key={`p-${index}-${pIdx}`}
                  className="message-paragraph"
                  dangerouslySetInnerHTML={{ __html: processText(p) }}
                />
              );
            });
        })}
      </div>
    );
  };

  const highlightSearchMatch = (text, query) => {
    if (!query) return text;

    const parts = text.split(new RegExp(`(${query})`, 'gi'));
    return parts.map((part, i) =>
      part.toLowerCase() === query.toLowerCase() ?
        <span key={i} className="text-danger fw-bold">{part}</span> :
        part
    );
  };

  const filteredChats = (chats) => {
    return chats.filter(chat => {
      const matchesTitle = chat.title.toLowerCase().includes(searchQuery.toLowerCase());
      const matchesMessages = chat.messages.some(msg =>
        msg.text.toLowerCase().includes(searchQuery.toLowerCase())
      );
      return matchesTitle || matchesMessages;
    }).map(chat => ({
      ...chat,
      highlightedTitle: highlightSearchMatch(chat.title, searchQuery),
      highlightedMessages: chat.messages.map(msg => ({
        ...msg,
        highlightedText: highlightSearchMatch(msg.text, searchQuery)
      }))
    }));
  };

  const renderMessageContent = (msg) => {
    switch (msg.type) {
      case 'typing':
        return (
          <div className="d-flex align-items-center gap-2">
            <div className="spinner-grow spinner-grow-sm text-light" role="status" />
          </div>
        );

      case 'image':
        return (
          <div className="message-content">
            <div className="bot-message">
              <img
                src={`http://localhost:8000${msg.image_url}`}
                alt={msg.text}
                className="img-fluid rounded"
                style={{ maxHeight: '300px' }}
              />
              <p className="mt-2 mb-0">{msg.text}</p>
            </div>
          </div>
        );

      case 'image-upload':
        return (
          <div className="message-content d-flex flex-column gap-2">
            {/* Render all images if present */}
            {Array.isArray(msg.image_urls) && msg.image_urls.length > 0 && (
              <div className="d-flex flex-wrap gap-2">
                {msg.image_urls.map((url, idx) => (
                  <div
                    key={idx}
                    style={{ width: '70px', height: '70px', borderRadius: '6px', overflow: 'hidden' }}
                  >
                    <img
                      src={`http://localhost:8000${url}`}
                      alt={`Uploaded ${idx}`}
                      className="img-fluid w-100 h-100 object-fit-cover"
                      onError={(e) => {
                        e.target.onerror = null;
                        e.target.src = 'placeholder-image-url'; // 👈 Replace this with your placeholder
                      }}
                    />
                  </div>
                ))}
              </div>
            )}

            {/* TEXT below image, if exists */}
            {msg.text && (
              <p className="m-0" style={{ fontSize: '0.95rem', lineHeight: '1.5', color: '#ffffff' }}>
                {msg.text}
              </p>
            )}
          </div>

        );

      default:
        return (
          <div className="message-content">
            {msg.sender === 'bot' ? (
              <div className="bot-message">
                {formatMessageContent(msg.text, msg.type)}
              </div>
            ) : (
              <div className="user-message">
                {msg.text.split('\n').map((line, i) => <p key={i} className="mb-0">{line}</p>)}
              </div>
            )}
          </div>
        );
    }
  };

  const renderMessages = () => (
    <main className="flex-grow-1 overflow-auto p-3 bg-color1">
      <div className="d-flex flex-column gap-3">
        {messages.length === 0 ? (
          <div className="text-center mt-5">
            <div className="mb-4">
              <i className="bi bi-chat-square-text bg-color2 fs-1"></i>
            </div>
            <h5 className="bg-color2">Start a new conversation</h5>
            <p className="bg-color2">
              {selectedImages.length > 0 ?
                "You've selected images - add a message or send as is" :
                "Type a message below to begin chatting"}
            </p>
          </div>
        ) : (
          messages.map((msg) => (
            <div
              key={msg.id}
              className={`d-flex flex-column ${msg.sender === 'user' ? 'align-items-end' : 'align-items-start'
                }`}
            >
              <div
                className={`message-container p-3 rounded-3 ${msg.sender === 'user' ?
                  'primary text-white' :
                  msg.type === 'typing' ?
                    'shadow' :
                    'text-dark shadow-sm shadow'
                  }`}
                style={{ maxWidth: '85%' }}
              >
                {renderMessageContent(msg)}

                <div className="text-start mt-1">
                  <small className={`text-opacity-75 ${msg.sender === 'user' ? 'text-white' : ''
                    }`}>
                    {new Date(msg.timestamp).toLocaleTimeString([], {
                      hour: '2-digit',
                      minute: '2-digit'
                    })}
                  </small>
                </div>
              </div>

              {msg.sender === 'bot' && msg.type !== 'typing' && !isProcessing && !isTyping && (
                <div className="d-flex justify-content-start gap-2 mt-1 ms-3" style={{ maxWidth: '75%' }}>
                  <button
                    className="btn btn-sm buttonn"
                    onClick={() => handleCopy(msg.text, msg.id)}
                    title="Copy message"
                  >
                    <i className={copiedMessageId === msg.id ? "bi bi-clipboard-check" : "bi bi-copy"}></i>
                  </button>
                  <button
                    className="btn btn-sm buttonn"
                    onClick={() => handleRegenerate(msg.id)}
                    title="Regenerate response"
                    disabled={regeneratingMessageId === msg.id}
                  >
                    <i className={regeneratingMessageId === msg.id ? "bi bi-check" : "bi bi-arrow-repeat"}></i>
                  </button>
                </div>
              )}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>
    </main>
  );

  const renderInputArea = () => (
    <footer className="bg-color1 py-3 d-flex justify-content-center">
      <form onSubmit={handleSendMessage} style={{ width: '100%', maxWidth: '760px' }}>
        <div className="d-flex overflow-auto pb-2" style={{ gap: '8px' }}>
          {selectedImages.map((image) => (
            <div key={image.id} className="position-relative flex-shrink-0">
              <img
                src={image.preview}
                alt={`Preview ${image.id}`}
                style={{
                  height: '50px',
                  width: '50px',
                  objectFit: 'cover',
                  borderRadius: '4px'
                }}
              />
              <button
                type="button"
                onClick={() => removeImage(image.id)}
                aria-label="Remove image"
                className="btn btn-sm btn-danger p-0 d-flex align-items-center justify-content-center"
                style={{
                  position: 'absolute',
                  top: '-1px',
                  right: '-8px',
                  width: '15px',
                  height: '15px',
                  borderRadius: '50%'
                }}
              >
                <i className="bi bi-x" style={{ fontSize: '0.7rem' }}></i>
              </button>
            </div>
          ))}
        </div>
        <div
          className="shadow-sm px-3 py-3"
          style={{
            backgroundColor: 'rgb(80, 78, 78)',
            borderRadius: '30px',
            color: 'white',
            boxShadow: '12px 4px 4px 12px rgba(0, 0, 0, 0.17)',
          }}
        >
          {/* Image preview section */}
          {selectedImages.length > 0 && (
            <div className="mb-2">
              <div className="d-flex  justify-content-between align-items-center mb-2">
                <small className="text-muted">
                  {selectedImages.length} image{selectedImages.length !== 1 ? 's' : ''} selected
                </small>
                <button
                  type="button"
                  className="btn btn-sm btn-outline-danger"
                  onClick={clearSelectedImages}
                >
                  Clear all
                </button>
              </div>

            </div>
          )}

          {/* Text input */}
          <textarea
            rows={1}
            className="form-control bg-transparent text-light ps-3 pt-2"
            value={inputValue}
            onChange={(e) => {
              setInputValue(e.target.value);
              e.target.style.height = 'auto';
              e.target.style.height = `${Math.min(e.target.scrollHeight, 150)}px`;
            }}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey && !(isProcessing || isTyping)) {
                e.preventDefault();
                handleSendMessage(e);
              }
            }}
            placeholder={
              selectedImages.length > 0 ?
                "Add a message about these images (optional)" :
                "Type your message..."
            }
            ref={inputRef}
            style={{
              resize: 'none',
              border: 'none',
              boxShadow: 'none',
              minHeight: '44px',
              maxHeight: '180px',
              overflowY: 'auto',
              overflowWrap: 'break-word',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
              fontSize: '1rem',
            }}
          />

          {/* Input actions */}
          <div className="d-flex justify-content-between align-items-center mt-3 flex-wrap">
            <div className="d-flex align-items-center gap-3">
              <div className="position-relative">
                <input
                  type="file"
                  id="image-upload"
                  ref={fileInputRef}
                  accept="image/*"
                  className="d-none"
                  onChange={handleImageUpload}
                  multiple
                  disabled={selectedImages.length >= MAX_IMAGES}
                />
                <label
                  htmlFor="image-upload"
                  className={`btn btn-sm ${selectedImages.length >= MAX_IMAGES ? 'btn-outline-secondary disabled' : 'color-3'}`}
                  title={selectedImages.length >= MAX_IMAGES ?
                    `Maximum ${MAX_IMAGES} images allowed` : ""}
                >
                  <i className="bi bi-images me-1"></i>
                  {selectedImages.length > 0 ?
                    `${selectedImages.length}/${MAX_IMAGES}` : ''}
                </label>
              </div>
            </div>

            <button
              type="submit"
              onClick={cancelRequest}
              className={`btn rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping || isUploadingImages ?
                'color-4' : 'color-4'
                }`}
            >

              {(isProcessing || isTyping || isUploadingImages) ? (
                <>
                  <span className="spinner-border spinner-border-sm spinner text-light" role="status" />
                </>
              ) : (
                <>
                  <i className="bi bi-send"></i>
                </>
              )}
            </button>
          </div>
        </div>

        <div className="text-center mt-2">
          <small className="text-white">
            {isProcessing || isTyping || isUploadingImages ? (
              <button
                type="button"
                className="btn btn-sm btn-outline-danger"
                onClick={cancelRequest}
              >
                <i className="bi bi-stop-circle me-1"></i> Stop
              </button>
            ) : (
              'Press Enter to send, Shift+Enter for new line'
            )}
          </small>
        </div>
      </form>
    </footer>
  );

  return (
    <div className="d-flex vh-100">
      {/* Delete Confirmation Modal */}
      <div className={`modal fade ${showDeleteModal ? 'show' : ''}`}
        style={{ display: showDeleteModal ? 'block' : 'none' }}
        tabIndex="-1">
        <div className="modal-dialog modal-dialog-centered">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title">Confirm Deletion</h5>
              <button type="button" className="btn-close" onClick={() => setShowDeleteModal(false)}></button>
            </div>
            <div className="modal-body">
              <p>Are you sure you want to delete this chat? This action cannot be undone.</p>
            </div>
            <div className="modal-footer">
              <button type="button" className="btn btn-outline-secondary" onClick={() => setShowDeleteModal(false)}>Cancel</button>
              <button type="button" className="btn btn-danger" onClick={handleDelete}>
                <i className="bi bi-trash me-1"></i> Delete
              </button>
            </div>
          </div>
        </div>
      </div>
      {showDeleteModal && <div className="modal-backdrop fade show"></div>}

      {/* Search Modal */}
      <div className={`modal fade ${showSearchModal ? 'show' : ''}`}
        style={{
          display: showSearchModal ? 'block' : 'none',
          background: 'rgba(26, 25, 25, 0.6)'
        }}
        tabIndex="-1"
        onClick={(e) => {
          // Close modal when clicking outside the modal content
          if (e.target === e.currentTarget) {
            setShowSearchModal(false);
          }
        }}
      >
        <div className="modal-dialog modal-dialog-centered justify-content-between align-items-center" style={{ maxWidth: '650px' }}>
          <div className="modal-content bg-color3 rounded-3 pb-3" style={{
            border: 'none',
            boxShadow: '0 0 20px rgba(0, 0, 0, 0.3)'
          }}>
            <div className="modal-header border-0">
              <div className="w-100">
                <div className="input-group">
                  <span className="input-group-text bg-transparent border-0">
                    <i className="bi bi-search text-muted"></i>
                  </span>
                  <input
                    type="text"
                    className="form-control border-0 shadow-none"
                    placeholder="Search chats..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    autoFocus
                    ref={searchInputRef}
                    style={{
                      fontSize: '1rem',
                      padding: '0.75rem 0',
                      backgroundColor: 'transparent'
                    }}
                  />
                  <button
                    className="input-group-text bg-transparent border-0"
                    type="button"
                    onClick={() => setShowSearchModal(false)}
                    style={{ cursor: 'pointer' }}
                  >
                    <i className="bi bi-x-lg bg-change"></i>
                  </button>
                </div>
              </div>
            </div>

            <div className="modal-body p-0">
              <div className="search-results" style={{
                maxHeight: '60vh',
                overflowY: 'auto',
                padding: '0 1rem'
              }}>
                {filteredChats([...chatHistory, ...archivedChats]).length === 0 ? (
                  <div className="text-muted text-center">
                    <i className="bi bi-search fs-4 mb-2 d-block"></i>
                    No chats found matching your search
                  </div>
                ) : (
                  <div className="list-group list-group-flush">
                    {/* Today's Chats */}
                    {filteredChats([...chatHistory, ...archivedChats])
                      .filter(chat => {
                        const chatDate = new Date(chat.updatedAt || chat.createdAt);
                        const today = new Date();
                        return chatDate.toDateString() === today.toDateString();
                      })
                      .length > 0 && (
                        <div className="text-muted small "></div>
                      )}

                    {filteredChats([...chatHistory, ...archivedChats])
                      .filter(chat => {
                        const chatDate = new Date(chat.updatedAt || chat.createdAt);
                        const today = new Date();
                        return chatDate.toDateString() === today.toDateString();
                      })
                      .sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
                      .map(chat => (
                        <div
                          key={chat.id}
                          className={`list-group-item list-group-item-action border-0 px-3 py-2 ${activeChat === chat.id ? 'active' : ''}`}
                          onClick={() => {
                            loadChat(chat.id);
                            setShowSearchModal(false);
                          }}
                          style={{
                            borderRadius: '6px',
                            marginBottom: '4px'
                          }}
                        >
                          <div className="d-flex justify-content-between align-items-center">
                            <div className="text-truncate">
                              {chat.highlightedTitle || chat.title}
                            </div>
                            <div className="d-flex align-items-center">
                              <small className="text-muted me-2">
                                {new Date(chat.updatedAt || chat.createdAt).toLocaleTimeString([], {
                                  hour: '2-digit',
                                  minute: '2-digit'
                                })}
                              </small>
                              <button
                                className="btn btn-sm btn-link text-muted p-0"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setEditingChatId(chat.id);
                                  setTempTitle(chat.title);
                                }}
                              >
                                <i className="bi bi-pencil"></i>
                              </button>
                            </div>
                          </div>

                          {/* Message preview */}
                          {chat.highlightedMessages
                            .filter(msg => msg.highlightedText !== msg.text)
                            .slice(0, 1)
                            .map((msg, idx) => (
                              <div key={idx} className="text-muted small text-truncate mt-1">
                                {msg.sender === 'user' ? 'You: ' : 'Assistant: '}
                                {msg.highlightedText}
                              </div>
                            ))}
                        </div>
                      ))}

                    {/* Yesterday's Chats */}
                    {filteredChats([...chatHistory, ...archivedChats])
                      .filter(chat => {
                        const chatDate = new Date(chat.updatedAt || chat.createdAt);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        return chatDate.toDateString() === yesterday.toDateString();
                      })
                      .length > 0 && (
                        <div className="text-muted small px-3 pt-3">Yesterday</div>
                      )}

                    {filteredChats([...chatHistory, ...archivedChats])
                      .filter(chat => {
                        const chatDate = new Date(chat.updatedAt || chat.createdAt);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        return chatDate.toDateString() === yesterday.toDateString();
                      })
                      .sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
                      .map(chat => (
                        <div
                          key={chat.id}
                          className={`list-group-item list-group-item-action border-0 px-3 py-2 ${activeChat === chat.id ? 'active' : ''}`}
                          onClick={() => {
                            loadChat(chat.id);
                            setShowSearchModal(false);
                          }}
                          style={{
                            borderRadius: '6px',
                            marginBottom: '4px'
                          }}
                        >
                          <div className="d-flex justify-content-between align-items-center">
                            <div className="text-truncate">
                              {chat.highlightedTitle || chat.title}
                            </div>
                            <div className="d-flex align-items-center">
                              <small className="text-muted me-2">
                                {new Date(chat.updatedAt || chat.createdAt).toLocaleTimeString([], {
                                  hour: '2-digit',
                                  minute: '2-digit'
                                })}
                              </small>
                              <button
                                className="btn btn-sm btn-link text-muted p-0"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setEditingChatId(chat.id);
                                  setTempTitle(chat.title);
                                }}
                              >
                                <i className="bi bi-pencil"></i>
                              </button>
                            </div>
                          </div>

                          {/* Message preview */}
                          {chat.highlightedMessages
                            .filter(msg => msg.highlightedText !== msg.text)
                            .slice(0, 1)
                            .map((msg, idx) => (
                              <div key={idx} className="text-muted small text-truncate mt-1">
                                {msg.sender === 'user' ? 'You: ' : 'Assistant: '}
                                {msg.highlightedText}
                              </div>
                            ))}
                        </div>
                      ))}

                    {/* Previous 7 Days */}
                    {filteredChats([...chatHistory, ...archivedChats])
                      .filter(chat => {
                        const chatDate = new Date(chat.updatedAt || chat.createdAt);
                        const weekAgo = new Date();
                        weekAgo.setDate(weekAgo.getDate() - 7);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        return chatDate > weekAgo && chatDate.toDateString() !== yesterday.toDateString() && chatDate.toDateString() !== new Date().toDateString();
                      })
                      .length > 0 && (
                        <div className="text-muted small px-3 pt-3">Previous 7 Days</div>
                      )}

                    {filteredChats([...chatHistory, ...archivedChats])
                      .filter(chat => {
                        const chatDate = new Date(chat.updatedAt || chat.createdAt);
                        const weekAgo = new Date();
                        weekAgo.setDate(weekAgo.getDate() - 7);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        return chatDate > weekAgo && chatDate.toDateString() !== yesterday.toDateString() && chatDate.toDateString() !== new Date().toDateString();
                      })
                      .sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
                      .map(chat => (
                        <div
                          key={chat.id}
                          className={`list-group-item list-group-item-action border-0 px-3 py-2 ${activeChat === chat.id ? 'active' : ''}`}
                          onClick={() => {
                            loadChat(chat.id);
                            setShowSearchModal(false);
                          }}
                          style={{
                            borderRadius: '6px',
                            marginBottom: '4px'
                          }}
                        >
                          <div className="d-flex justify-content-between align-items-center">
                            <div className="text-truncate">
                              {chat.highlightedTitle || chat.title}
                            </div>
                            <div className="d-flex align-items-center">
                              <small className="text-muted me-2">
                                {formatDate(chat.updatedAt || chat.createdAt)}
                              </small>
                              <button
                                className="btn btn-sm btn-link text-muted p-0"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setEditingChatId(chat.id);
                                  setTempTitle(chat.title);
                                }}
                              >
                                <i className="bi bi-pencil"></i>
                              </button>
                            </div>
                          </div>

                          {/* Message preview */}
                          {chat.highlightedMessages
                            .filter(msg => msg.highlightedText !== msg.text)
                            .slice(0, 1)
                            .map((msg, idx) => (
                              <div key={idx} className="text-muted small text-truncate mt-1">
                                {msg.sender === 'user' ? 'You: ' : 'Assistant: '}
                                {msg.highlightedText}
                              </div>
                            ))}
                        </div>
                      ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
      {showSearchModal && <div className="modal-backdrop fade show"></div>}

      {/* Sidebar */}
      <div
        ref={sidebarRef}
        className={`sidebar bg-color3 shadow-sm ${isSidebarVisible ? 'visible' : 'hidden'}`}
      >
        {/* Header row for close (slider) */}
        <div className="d-flex justify-content-between align-items-center px-3 pt-3">
          <div className="fw-bold fs-6 text-white"></div>

          {isSidebarVisible && (
            <button
              className="btn color-6 btn-sm"
              onClick={toggleSidebar}
              aria-label="Close sidebar"
              style={{ lineHeight: '1' }}
              title='close sidebar'
            >
              <i className="bi bi-layout-sidebar-inset-reverse"></i>
            </button>
          )}
        </div>

        {/* New Chat button */}
        <div className="d-flex px-2 pt-3">
          <button
            onClick={startNewChat}
            className="btn btn-outline-secondary border-0 text-start d-flex gap-2 w-100"
            disabled={isTyping || isProcessing}
          >
            <i className="fa-regular fa-pen-to-square pt-1"></i>
            <span className="text-truncate">New Chat</span>
          </button>
        </div>

        {/* Search Button */}
        <div className="p-2">
          <div className="input-group">
            <button
              className="btn btn-outline-secondary w-100 border-0 text-start  d-flex"
              onClick={() => setShowSearchModal(true)}
            >
              <i className="bi bi-search me-2"></i>
              <span className="text-truncate">Search chats</span>
            </button>
          </div>
        </div>
        <div className="p-3">
          <div className="d-flex justify-content-between align-items-center mb-2">
            <h6 className="text-muted mb-0">
              {showArchived ? 'Archived Chats' : 'Recent Chats'}
            </h6>
            <button
              className="btn btn-sm btn-outline-secondary"
              onClick={() => setShowArchived(!showArchived)}
              title={showArchived ? 'Show active chats' : 'Show archived chats'}
            >
              {showArchived ? (
                <i className="bi bi-inbox"></i>
              ) : (
                <i className="bi bi-archive"></i>
              )}
            </button>
          </div>

          <div className="list-group list-group-flush chat-list">
            {filteredChats(showArchived ? archivedChats : chatHistory).length === 0 ? (
              <div className="text-muted p-3 text-center">
                <i className="bi bi-chat-square-text fs-4 mb-2 d-block"></i>
                No {showArchived ? 'archived' : 'active'} chats found
              </div>
            ) : (
              filteredChats(showArchived ? archivedChats : chatHistory)
                .sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
                .map(chat => (
                  <div
                    key={chat.id}
                    className={`list-group-item bg-color7 list-group-item-action px-3 py-2 ${activeChat === chat.id ? 'active' : ''}`}
                    onClick={() => !editingChatId && loadChat(chat.id)}
                  >
                    <div className="d-flex justify-content-between align-items-start">
                      <div className="flex-grow-1 me-2" style={{ minWidth: 0 }}>
                        <div
                          style={{
                            maxWidth: '180px',
                            height: '1.5rem',
                            lineHeight: '1.5rem',
                            fontSize: '0.95rem',
                            display: 'flex',
                            alignItems: 'center',
                          }}
                          onClick={(e) => {
                            if (!editingChatId) return; // ignore accidental clicks
                            e.stopPropagation();
                          }}
                        >
                          {editingChatId === chat.id && renameSource === 'sidebar' ? (
                            <input
                              ref={renameInputRef}
                              type="text"
                              className="form-control form-control-sm fw-semibold border-0 p-0 m-0"
                              style={{
                                height: '1.5rem',
                                lineHeight: '1.5rem',
                                fontSize: '0.95rem',
                                backgroundColor: 'transparent',
                                boxShadow: 'none',
                              }}
                              value={tempTitle}
                              onChange={(e) => setTempTitle(e.target.value)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') handleRenameInline(chat.id);
                                if (e.key === 'Escape') {
                                  setEditingChatId(null);
                                  setTempTitle('');
                                }
                              }}
                              onBlur={() => handleRenameInline(chat.id)}
                              autoFocus
                            />
                          ) : (
                            <span
                              className="text-truncate text-start fw-semibold"
                              style={{
                                maxWidth: '100%',
                                cursor: 'pointer',
                                flex: 1,
                                whiteSpace: 'nowrap',
                                overflow: 'hidden',
                                textOverflow: 'ellipsis',
                              }}
                              onClick={(e) => {
                                e.stopPropagation();
                                setEditingChatId(chat.id);
                                setTempTitle(chat.title);
                                setRenameSource('sidebar');
                                setTimeout(() => renameInputRef.current?.focus(), 0);
                              }}
                            >
                              {chat.highlightedTitle || chat.title}
                            </span>
                          )}
                          {!editingChatId && (
                            <>
                              <small className="text-muted">
                                {formatDate(chat.updatedAt || chat.createdAt)}
                              </small>
                              {chat.archivedAt && (
                                <span className="badge bg-secondary ms-2">Archived</span>
                              )}
                            </>
                          )}
                        </div>
                      </div>

                      {!editingChatId && (
                        <div className="dropdown">
                          <button
                            className="btn btn-sm border-0 p-0 d-flex align-items-center justify-content-center chat-menu-trigger"
                            type="button"
                            data-bs-toggle="dropdown"
                            aria-expanded="false"
                            style={{ width: '24px', height: '24px' }}
                            onClick={(e) => e.stopPropagation()}
                          >
                            <div className="d-flex gap-1 color-7">
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                            </div>
                          </button>
                          <ul className="dropdown-menu dropdown-menu-end shadow-sm">
                            <li>
                              <button
                                className="dropdown-item text-light"
                                onClick={(e) => {
                                  e.preventDefault();
                                  setEditingChatId(chat.id);
                                  setTempTitle(chat.title);
                                  setRenameSource('sidebar'); // Add this line
                                  setTimeout(() => {
                                    renameInputRef.current?.focus();
                                  }, 0);
                                }}
                              >
                                <i className="bi bi-pencil me-2"></i>Rename
                              </button>
                            </li>

                            <li>
                              <button
                                className="dropdown-item text-light"
                                onClick={(e) => {
                                  e.preventDefault();
                                  handleShare(chat.id);
                                }}
                              >
                                <i className="bi bi-share me-2"></i>Share
                              </button>
                            </li>
                            {showArchived ? (
                              <li>
                                <button
                                  className="dropdown-item text-light"
                                  onClick={(e) => {
                                    e.preventDefault();
                                    handleUnarchive(chat.id);
                                  }}
                                >
                                  <i className="bi bi-inbox me-2"></i>Unarchive
                                </button>
                              </li>
                            ) : (
                              <li>
                                <button
                                  className="dropdown-item text-light"
                                  onClick={(e) => {
                                    e.preventDefault();
                                    handleArchive(chat.id);
                                  }}
                                >
                                  <i className="bi bi-archive me-2"></i>Archive
                                </button>
                              </li>
                            )}
                            <li><hr className="dropdown-divider" /></li>
                            <li>
                              <button
                                className="dropdown-item text-danger"
                                onClick={(e) => {
                                  e.preventDefault();
                                  confirmDelete(chat.id);
                                }}
                              >
                                <i className="bi bi-trash me-2"></i>Delete
                              </button>
                            </li>
                          </ul>
                        </div>
                      )}
                    </div>
                  </div>
                ))
            )}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className={`flex-grow-1 d-flex flex-column ${isSidebarVisible ? 'ms-sidebar' : 'ms-collapsed-sidebar'}`}>
        {/* Header */}
        <header className="bg-color p-4 d-flex align-items-center justify-content-between sticky-top">
          {!isSidebarVisible && (
            <div className="collapsed-sidebar d-flex flex-column align-items-center py-3 ">
              <button
                className="btn btn-sm color-5 "
                onClick={toggleSidebar}
                aria-label="Open sidebar"
                title='open sidebar'
              >
                <i className="bi bi-layout-sidebar-inset"></i>
              </button>

              <button
                onClick={startNewChat}
                className="btn btn-outline-secondary border-0 mt-5"
                disabled={isTyping || isProcessing}
              >
                <i className="fa-regular fa-pen-to-square "></i>
              </button>

              <button
                className="btn btn-outline-secondary border-0 mt-2"
                onClick={() => setShowSearchModal(true)}
              >
                <i className="bi bi-search "></i>
              </button>
            </div>
          )}

          <div className="d-flex justify-content-center align-items-center flex-grow-1">
            {editingChatId === activeChat && renameSource === 'header' ? (
              <input
                ref={renameInputRef}
                className="form-control text-center fw-semibold border-1 border-blue p-0 m-0"
                style={{
                  maxWidth: '300px',
                  height: '2.2rem',
                  fontSize: '1.4rem',
                  lineHeight: '2.2rem',
                  boxShadow: 'none',
                }}
                value={tempTitle}
                onChange={(e) => setTempTitle(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') handleRenameInline(activeChat);
                  if (e.key === 'Escape') {
                    setEditingChatId(null);
                    setTempTitle('');
                  }
                }}
                onBlur={() => handleRenameInline(activeChat)}
                autoFocus
              />
            ) : (
              <h4
                className="mb-0 fw-semibold color-5 text-truncate text-center"
                onClick={() => {
                  const found = [...chatHistory, ...archivedChats].find(c => c.id === activeChat);
                  if (found) {
                    setEditingChatId(activeChat);
                    setTempTitle(found.title);
                    setRenameSource('header');
                    setTimeout(() => renameInputRef.current?.focus(), 0);
                  }
                }}
                style={{
                  maxWidth: '300px',
                  height: '2.2rem',
                  lineHeight: '2.2rem',
                  fontSize: '1.4rem',
                  cursor: 'pointer',
                }}
              >
                {[...chatHistory, ...archivedChats].find(c => c.id === activeChat)?.title || 'New Chat'}
              </h4>
            )}
          </div>
          <div style={{ width: 40 }}></div>
        </header>

        {/* Messages Area */}
        {renderMessages()}

        {/* Input Area */}
        {renderInputArea()}
      </div>

      <ToastContainer
        position="top-right"
        autoClose={2000}
        hideProgressBar={false}
        newestOnTop={true}
        closeOnClick
        pauseOnHover={false}
        draggable
      />
    </div>
  );
}

export default Home;

home.css :

/* ============ BASE & LAYOUT ============ */
.chat-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  transition: margin-left 0.3s ease;
}

/* ============ SIDEBAR ============ */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 285px;
  height: 100vh;
  background-color: #1e1e1e;
  z-index: 1000;
  transform: translateX(-100%);
  transition: transform 0.3s ease-in-out;
  overflow-y: auto;
  box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
}

/* Default state - visible on larger screens */
.sidebar:not(.forced-hidden) {
  transform: translateX(0);
}

.sidebar.visible {
  transform: translateX(0);
}

.sidebar.hidden {
  transform: translateX(-100%);
}

.ms-sidebar {
  margin-left: 285px;
  width: calc(100% - 285px);
  transition: margin-left 0.3s ease-in-out;
}

/* ============ MESSAGES ============ */
.message-container {
  max-width: 60%;
  word-wrap: break-word;
  box-shadow: none !important;
  margin-left: 10px;
}

.list-group-item:not(.active):hover {
  background-color: #292929 !important;
  color: #fff;
  transition: background-color 0.3s ease-in-out;
  border-radius: 8px 8px 8px 8px;
}

.message-content {
  white-space: pre-wrap;
  text-align: left;
}

.user-message p {
  margin-bottom: 0;
}

.bot-message p:last-child {
  margin-bottom: 0;
}

/* Message formatting */
.message-heading {
  font-size: 1.05rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.message-paragraph {
  line-height: 1.6;
  margin-bottom: 0.5rem;
}

.message-list {
  padding-left: 1.5rem;
  margin-bottom: 0.5rem;
}

.code-block {
  background-color: #2d2d2d;
  color: #f8f8f2;
  border-radius: 6px;
  padding: 0.75rem;
  font-family: 'Courier New', Courier, monospace;
  font-size: 0.85rem;
  line-height: 1.5;
  margin: 0.5rem 0;
  overflow-x: auto;
}

.code-block pre {
  margin: 0;
  white-space: pre-wrap;
  word-break: break-word;
}

.list-group {
  cursor: pointer;
}

/* ============ TYPING INDICATOR ============ */
.typing-dots {
  display: flex;
  align-items: center;
  gap: 4px;
}

.typing-dots .dot {
  width: 8px;
  height: 8px;
  background-color: #888;
  border-radius: 50%;
  animation: blink 1.4s infinite both;
}

.typing-dots .dot:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-dots .dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes blink {
  0%, 80%, 100% {
    opacity: 0;
  }
  40% {
    opacity: 1;
  }
}

/* ============ FORM CONTROLS ============ */
.form-control {
  box-shadow: rgba(2, 97, 198, 0.265) 0 0 0 1.6px;
  background-color: #2d2d2d;
  color: #ffffff;
  border: 1px solid #444;
}

.form-control:focus {
  box-shadow: rgba(0, 123, 255, 0.25) 0 0 0 0.2rem;
  border-color: #86b7fe;
  background-color: #2d2d2d;
  color: #ffffff;
}

/* ============ DROPDOWN MENUS ============ */
.dropdown-menu {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  border: none;
  background-color: #2d2d2d;
}

.dropdown-item {
  padding: 0.5rem 1rem;
  color: #e0e0e0;
}

.dropdown-item:hover {
  background-color: #3a3a3a;
  color: #ffffff;
}

.dropdown-divider {
  margin: 0.25rem 0;
  border-color: #444;
}

/* ============ MODALS & TOASTS ============ */
.modal {
  background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
  background-color: #2d2d2d;
  color: #e0e0e0;
}

.toast {
  margin-bottom: 0.5rem;
  background-color: #2d2d2d;
  color: #e0e0e0;
}

/* ============ UTILITY CLASSES ============ */
.sticky-top {
  position: sticky;
  top: 0;
  z-index: 900;
}

.text-truncate {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}

.active {
  background-color: #3a3a3a !important;
  color: white !important;
  border: none;  
  border-radius: 7px !important;
}

/* ============ SCROLLBARS ============ */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* ============ RESPONSIVE ADJUSTMENTS ============ */
@media (max-width: 1200px) {
  .sidebar {
    width: 250px;
  }
  
  .ms-sidebar {
    margin-left: 250px;
    width: calc(100% - 250px);
  }
}

@media (max-width: 992px) {
  .sidebar {
    width: 240px;
  }
  
  .ms-sidebar {
    margin-left: 240px;
    width: calc(100% - 240px);
  }
  
  .message-container {
    max-width: 80%;
  }
}

@media (max-width: 768px) {
  .sidebar {
    width: 260px;
    box-shadow: 4px 0 15px rgba(0, 0, 0, 0.4);
  }
  
  .ms-sidebar {
    margin-left: 0;
    width: 100%;
  }
  
  .ms-collapsed-sidebar {
    margin-left: 0;
    width: 100%;
  }

  /* Overlay effect for mobile */
  .sidebar:not(.forced-visible) {
    transform: translateX(-100%);
    width: 260px;
  }
  
  .sidebar.forced-visible {
    transform: translateX(0);
    width: 260px;
  }
  
  /* Overlay effect when sidebar is visible */
  .sidebar.forced-visible + .ms-sidebar::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999;
    pointer-events: auto;
  }
  
  .message-container {
    max-width: 85%;
  }
}

@media (max-width: 576px) {
  .sidebar {
    width: 85%;
  }
  
  .chat-list-item {
    padding: 0.6rem;
  }
  
  .message-container {
    max-width: 90%;
  }
  
  .message-heading {
    font-size: 1rem;
  }
  
  .code-block {
    font-size: 0.8rem;
    padding: 0.6rem;
  }

  .sidebar:not(.forced-visible) {
    width: 85%;
  }
  
  .sidebar.forced-visible {
    width: 85%;
  }
}

/* ============ COMPONENT SPECIFIC STYLES ============ */
.dot {
  padding-right: 10px;
}

.list-group-item .chat-menu-trigger {
  opacity: 0;
}

/* Show three dots on hover */
.list-group-item:hover .chat-menu-trigger {
  opacity: 1 !important;
  transition: opacity 0.2s ease !important;
}

/* Optional: Make the dots more visible on hover */
.list-group-item:hover .chat-menu-trigger .rounded-circle {
  background-color: #bbbdbf !important;
}

/* Code block styling */
.code-block-container {
  position: relative;
}

.code-actions {
  opacity: 0;
  transition: opacity 0.2s ease;
}

.code-block-container:hover .code-actions {
  opacity: 1;
}

/* Message action buttons */
.bot-message .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.75rem;
}

/* Ensure code blocks have proper spacing */
pre {
  white-space: pre;
  overflow-x: auto;
}

/* Inline code styling */
.inline-code {
  background-color: #3a3a3a;
  padding: 0.2em 0.4em;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.9em;
  color: #f8f8f2;
}

/* Message action buttons */
.bot-message .btn {
  padding: 0.25rem 0.5rem;
  font-size: 0.75rem;
  margin-left: 0.5rem;
}

/* Disabled button styling */
.bot-message .btn:disabled {
  opacity: 0.5;
}

.buttonn {
  font-size: smaller;
  border: none;
  color: rgb(180, 180, 180);
  background-color: transparent;
}

.buttonn:hover {
  background-color: #3a3a3a;
  color: white;
}

.buttonn1 {
  font-size: large;
  border: none;
  color: rgb(234, 233, 233);
  background-color: transparent;
}

.buttonn1:hover {
  background-color: #3e3c3c;
  color: rgb(177, 175, 175);
}

.noborder {
  border: none !important;
  box-shadow: none !important;
}

textarea {
  border: none;
  outline: none;
  background-color: #2d2d2d;
  color: white;
}

.spinner {
  font-size: smaller;
  margin-top: 2px;
  margin-bottom: 2px;
}

.plus-icon:hover {
  cursor: pointer;
}

.primary {
  background-color: #4c4b4b;
  border-radius: 10px !important;
  color: white;
}

.shadow {
  background-color: #303030;
  color: rgb(231, 229, 229) !important;
}

.bg-color {
  color: #cecece;
  background-color: #141414e1;
  border: none !important;
  box-shadow: none !important;
}

.bg-color1 {
  background-color: #141414e1;
}

.bg-color2 {
  color: #cecece;
}

.color-3 {
  background-color: rgb(80, 78, 78);
  color: #f8f8f2;
  border-radius: 10px;
}

.color-3:hover {
  background-color: #5c5c5c;
  color: #f8f8f2;
  border-radius: 10px;
}

.color-4 {
  background-color: #2928286d;
  color: #f8f8f2;
  border-radius: 10px;
}

.color-4:hover {
  background-color: #3a3a3a;
  color: #f8f8f2;
  border-radius: 10px;
}

.color-5 {
  color: rgb(206, 205, 205);
  font-size: larger;
  border-radius: 30%;
}

.color-5:hover {
  background-color: #323232;
  border-radius: 30%;
}

.color-6{
  color: rgb(255, 255, 255);
  border-radius: 25%;
  padding: 7px;
  font-size: large;
}

.color-6:hover{
  background-color: #323232;
  color: rgb(255, 255, 255);
  border-radius: 25%;
}

.color-7{
  color: white !important;
}

/* Input placeholder color */
::placeholder {
  color: #abaeb1 !important;
  opacity: 1;
}

/* Button styles */
.btn-outline-secondary {
  border-color: #444;
  color: #e0e0e0;
}

.btn-outline-secondary:hover {
  background-color: #3a3a3a;
  border-color: #555;
  color: white;
}

/* List group item styling */
.list-group-item {
  background-color: #1e1e1e;
  color: #e0e0e0;
  border-color: #2d2d2d;
}

.list-group-item:hover {
  background-color: #2a2a2a;
}

/* Badge styling */
.badge {
  background-color: #3a3a3a;
  color: white;
}

/* Text colors */
.text-muted {
  color: #8a8d91 !important;
}

/* Modal header */
.modal-header {
  border-bottom: 1px solid #444;
}

/* Modal footer */
.modal-footer {
  border-top: 1px solid #444;
}

/* Input group text */
.input-group-text {
  background-color: #2d2d2d;
  color: #e0e0e0;
  border-color: #444;
}

/* Extra small devices (phones, 400px and down) */
@media (max-width: 400px) {
  .sidebar {
    width: 90%;
  }
  
  .message-container {
    max-width: 95%;
  }
  
  .message-heading {
    font-size: 0.95rem;
  }
  
  .message-paragraph, .message-list {
    font-size: 0.9rem;
  }
  
  .code-block {
    font-size: 0.75rem;
    padding: 0.5rem;
  }
}

/* Add this to your home.css */
.sidebar .btn.color-5 {
  padding: 0.25rem 0.5rem;
  margin-right: 0.5rem;
}

/* Make sure the new chat button takes remaining space */
.sidebar .p-3.border-bottom {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Adjust header button spacing */
header .btn.color-5 {
  padding: 0.25rem 0.5rem;
}

.activechat{
  font-size: 145%;
  border: 1px solid #292929;
  padding: 10px;
}

.activechat1{
  font-size: 145%;
}

.chatrun{
  font-size: medium;
}

.collapsed-sidebar {
  width: 60px;
  background-color: #222222; /* same dark background as sidebar */
  height: 100vh;
  position: fixed;
  top: 0;
  left: 0;
}

.collapsed-sidebar i {
  cursor: pointer;
  transition: color 0.2s;
}

.collapsed-sidebar i:hover {
  color: #ccc;
}

.bg-change:hover{
  color: #969494;
  transition: color .1s ease-in-out;
}

.main-title{
  font-size: large;
  color: whitesmoke;
}

.color-8{
  color: hotpink;
}


import requests
from datetime import datetime
from pymongo import MongoClient
from duckduckgo_search import DDGS
import base64
from bson.binary import Binary
from io import BytesIO
import uuid
from PIL import Image
from bson import ObjectId
import os
from tempfile import NamedTemporaryFile
from typing import Union
import tempfile
from services.utils import save_image
import bcrypt
from google.oauth2 import id_token
from google.auth.transport import requests as google_requests

# Configuration
GROQ_API_KEY = "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"
STABILITY_API_KEY = "sk-3UnY9eVsTHi0V0NCCa5mVY61FwL4djjKakG7V3ePqs9vorgi"
API_URL = "https://api.groq.com/openai/v1/chat/completions"
STABILITY_API_URL = (
    "https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image"
)

# MongoDB setup
client = MongoClient("mongodb://localhost:27017/")
db = client["ai_new"]


uploaded_images_collection = db["uploaded_images"]
users_collection = db["users"]

user_info_collection = db["user_info"] 

def get_generated_images_collection():
    return db["uploaded_images"]

def save_uploaded_image(image_data: Union[bytes, str], user_id: str) -> str:
    """Save uploaded image (either bytes or base64) and return file path"""
    try:
        # Create user-specific directory if it doesn't exist
        user_dir = os.path.join(IMAGE_UPLOAD_DIR, user_id)
        os.makedirs(user_dir, exist_ok=True)

        # Generate unique filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"upload_{timestamp}_{uuid.uuid4().hex[:8]}.png"
        filepath = os.path.join(user_dir, filename)

        # Handle both base64 and raw bytes
        if isinstance(image_data, str):
            # Assume it's base64 if it's a string
            if image_data.startswith("data:image"):
                # Strip data URL prefix if present
                image_data = image_data.split(",", 1)[1]
            image_bytes = base64.b64decode(image_data)
        else:
            image_bytes = image_data

        # Save the image
        with open(filepath, "wb") as f:
            f.write(image_bytes)

        return filepath
    except Exception as e:
        print(f"Error saving uploaded image: {e}")
        raise

def process_image_with_llm(
    image_paths: list[str], prompt: str = None, history: list = None
) -> str:
    print("📤 Sending multiple images to LLM with prompt:", prompt)

    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    # Encode images
    image_parts = [
        {
            "type": "image_url",
            "image_url": {
                "url": f"data:image/png;base64,{base64.b64encode(open(p, 'rb').read()).decode('utf-8')}"
            },
        }
        for p in image_paths
    ]

    # Convert previous text + image history
    llm_messages = []
    if history:
        for msg in history:
            if msg.get("is_image", False):
                llm_messages.append(
                    {
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg['prompt']}",
                    }
                )
                llm_messages.append(
                    {
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg['response'].replace('IMAGE:', '')}",
                    }
                )
            else:
                llm_messages.append({"role": "user", "content": msg["prompt"]})
                llm_messages.append({"role": "assistant", "content": msg["response"]})

    # Add current image + prompt
    llm_messages.append(
        {"role": "user", "content": [{"type": "text", "text": prompt}] + image_parts}
    )

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": llm_messages,
        "max_tokens": 1500,
    }

    try:
        print("⏳ Requesting LLM...")
        response = requests.post(API_URL, headers=headers, json=data, timeout=60)
        print("✅ Response status:", response.status_code)
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    except Exception as e:
        print(f"❌ Error in LLM call: {e}")
        raise

def signup_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            # Google Sign-In case
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())
                
                # Extract all available Google profile information
                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),  # Profile picture URL
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")  # Unique Google ID
                }

                # Check if user already exists
                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success", 
                        "message": "User already exists", 
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create comprehensive user document
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,  # Store all Google data
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }
                
                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success", 
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Normal signup case (unchanged)
            username = data.get("username")
            email = data.get("email")
            password = data.get("password")

            if not all([username, email, password]):
                return {"status": "error", "message": "Missing fields"}

            if user_info_collection.find_one({"email": email}):
                return {"status": "error", "message": "Email already registered"}
            
            user_doc = {
                "username": username,
                "email": email,
                "password": password,
                "auth_type": "manual",
                "created_at": datetime.utcnow(),
                "last_login": datetime.utcnow()
            }
            inserted = user_info_collection.insert_one(user_doc)
            return {"status": "success", "user_id": str(inserted.inserted_id)}

    except Exception as e:
        print(f"Signup error: {e}")
        return {"status": "error", "message": str(e)}
    
def login_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())

                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")
                }

                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success",
                        "message": "User already exists (logged in)",
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create account if not exist
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }

                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success",
                    "message": "New Google user created",
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Manual login
            email = data.get("email")
            password = data.get("password")

            if not all([email, password]):
                return {"status": "error", "message": "Missing fields"}

            user = user_info_collection.find_one({"email": email, "auth_type": "manual"})
            if not user:
                return {"status": "error", "message": "User not found"}

            if user["password"] != password:
                return {"status": "error", "message": "Incorrect password"}

            return {
                "status": "success",
                "message": "Login successful",
                "user_id": str(user["_id"]),
                "profile_data": {
                    "email": user["email"],
                    "username": user["username"],
                }
            }

    except Exception as e:
        return {"status": "error", "message": str(e)}

def handle_image_upload(image_data_list, user_id, chat_id, prompt=None):
    try:
        image_urls = []
        image_ids = []
        image_binaries = []
        temp_file_paths = []

        # Save and collect info
        for image_data in image_data_list:
            filename = save_image(image_data)
            image_url = f"/image/{filename}"
            image_urls.append(image_url)
            image_ids.append(str(uuid.uuid4()))
            image_binaries.append(Binary(image_data))

            # Save temp file for LLM
            with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp_file:
                tmp_file.write(image_data)
                temp_file_paths.append(tmp_file.name)

        # Process with LLM if prompt exists
        llm_response = None
        if prompt:
            try:
                history_messages = get_chat_history(user_id, chat_id)
                llm_response = process_image_with_llm(
                    temp_file_paths, prompt, history=history_messages
                )
            except Exception as e:
                print(f"Error processing image with LLM: {str(e)}")
                llm_response = f"Error analyzing images: {str(e)}"

        # Clean up temp files
        for path in temp_file_paths:
            try:
                os.remove(path)
            except:
                pass

        # Save to uploaded_images collection
        image_doc = {
            "user_id": user_id,
            "chat_id": chat_id,
            "prompt": prompt,
            "image_data": image_binaries,
            "image_urls": image_urls,
            "image_ids": image_ids,
            "llm_response": llm_response,
            "created_at": datetime.utcnow(),
        }
        uploaded_images_collection.insert_one(image_doc)

        # Prepare success response
        response_data = {
            "status": "success",
            "image_ids": image_ids,
            "image_urls": image_urls,
            "message": "Images uploaded successfully",
            "llm_response": llm_response,
            "response": llm_response  # For backward compatibility
        }

        # Save to user's chat collection
        user_chats_col = get_user_conversations_collection(user_id)
        chat_doc = {
            "message_id": str(ObjectId()),
            "user_id": user_id,
            "chat_id": chat_id,
            "type": "image-upload",
            "prompt": prompt or "",
            "image_urls": image_urls,
            "response": llm_response or "Images received",
            "timestamp": datetime.utcnow()
        }
        
        # Update or create chat document
        user_chats_col.update_one(
            {"chat_id": chat_id},
            {
                "$setOnInsert": {
                    "title": prompt[:50] + "..." if prompt else "Image Upload",
                    "created_at": datetime.utcnow()
                },
                "$push": {"messages": chat_doc},
                "$set": {"updated_at": datetime.utcnow()}
            },
            upsert=True
        )

        return response_data

    except Exception as e:
        error_msg = f"Error uploading images: {str(e)}"
        print(error_msg)
        return {
            "status": "error",
            "error": str(e),
            "message": error_msg,
            "response": error_msg  # Ensure this exists
        }

def get_user_conversations_collection(user_id: str):
    """Get or create a conversations collection for a specific user"""
    return db[f"{user_id}"]

def users_info(user_id: str):
    chats_collection = get_user_conversations_collection(user_id)
    
    chat_docs = chats_collection.find({}, {"chat_id": 1, "title": 1, "created_at": 1,"messages":1})
    
    return chat_docs


def get_generated_images_collection():
    """Get the global generated images collection"""
    return db["generated_images"]


def search_web(query: str) -> str:
    print("Searching the web for: ", query)
    results = []
    with DDGS() as ddgs:
        for r in ddgs.text(query, max_results=10):
            snippet = f"{r['title']}: {r['body']}"
            results.append(snippet)
    return "\n".join(results)


def should_generate_image(prompt: str) -> bool:
    """Use the LLM to determine if the prompt is requesting an image generation"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the following user prompt to determine if the user is requesting an image to be generated.

    User Prompt: "{prompt}"

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.5,
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining image generation need: {e}")
        return False

def generate_image(prompt: str, user_id: str) -> dict:
    """Generate an image using Stability AI's API"""
    print(f"Generating image for prompt: {prompt}")
    
    headers = {
        "Authorization": f"Bearer {STABILITY_API_KEY}",
        "Content-Type": "application/json"
    }
    
    data = {
        "text_prompts": [{"text": prompt, "weight": 1}],
        "cfg_scale": 7,
        "height": 1024,
        "width": 1024,
        "samples": 1,
        "steps": 30,
    }
    
    try:
        response = requests.post(STABILITY_API_URL, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        response_data = response.json()
        
        if not response_data.get("artifacts"):
            raise Exception("No image artifacts in response")
            
        image_data = response_data["artifacts"][0]["base64"]
        image_bytes = base64.b64decode(image_data)
        
        # Save image information to the global images collection
        images_col = get_generated_images_collection()
        image_doc = {
            "user_id": user_id,
            "prompt": prompt,
            "generated_at": datetime.utcnow(),
            "model": "stable-diffusion-xl-1024-v1-0",
            "image_data": image_data  # Storing base64 for simplicity
        }
        image_id = images_col.insert_one(image_doc).inserted_id
        
        return {
            "type": "image",
            "image_bytes": image_bytes,
            "description": f"Generated image based on: '{prompt}'",
            "image_id": str(image_id)
        }
    except Exception as e:
        print(f"Image generation failed: {e}")
        raise

def should_perform_search(prompt: str, model_response: str) -> bool:
    """Determine if a web search is truly needed for this prompt"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the user's prompt and decide if a web search is ABSOLUTELY NECESSARY to answer correctly.
    Web search should ONLY be performed if:
    1. The question is about very recent events (last few days/weeks)
    2. The question requires real-time data (stock prices, sports scores, etc.)
    3. Your initial response indicates you don't know the answer
    4. The question is about specific facts not in your training data (after 2023)

    User Prompt: "{prompt}"
    Your Initial Response: "{model_response}"

    If any of the above conditions are met, respond with 'YES'.
    Otherwise, respond with 'NO'.

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.1,  # Lower temperature for more deterministic responses
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining search need: {e}")
        return False  # Default to no search if there's an error


def save_conversation(
    user_id: str,
    chat_id: str,
    prompt: str,
    response: str,
    title: str = None,
    is_image: bool = False,
):
    """Save conversation with title handling"""
    conversations_col = get_user_conversations_collection(user_id)

    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat:
        # New chat - use provided title or generate from prompt
        chat_title = (
            title
            if title
            else f"Chat: {prompt[:30]}..." if len(prompt) > 30 else f"Chat: {prompt}"
        )
        chat_doc = {
            "chat_id": chat_id,
            "user_id": user_id,
            "title": chat_title,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "messages": [],
        }
        conversations_col.insert_one(chat_doc)

    # Add message
    message = {
        "message_id": str(ObjectId()),
        "prompt": prompt,
        "response": response if not is_image else f"IMAGE:{response}",
        "is_image": is_image,
        "timestamp": datetime.utcnow(),
    }

    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$push": {"messages": message}, "$set": {"updated_at": datetime.utcnow()}},
    )

    print(f"Saved conversation for user {user_id} in chat {chat_id}")


def get_chat_history(user_id: str, chat_id: str, limit: int = 15):
    """Get the conversation history for a specific chat"""
    conversations_col = get_user_conversations_collection(user_id)
    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat or "messages" not in chat:
        return []

    # Return the most recent messages up to the limit
    return chat["messages"][-limit:]

def get_user_chats(user_id: str):
    conversations_col = get_user_conversations_collection(user_id)
    return list(
        conversations_col.find(
            {}, {"chat_id": 1, "title": 1, "created_at": 1, "updated_at": 1, "messages": 1}
        )
    )

def rename_chat(user_id: str, chat_id: str, new_title: str):
    """Rename a chat"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$set": {"title": new_title, "updated_at": datetime.utcnow()}},
    )


def delete_chat(user_id: str, chat_id: str):
    """Delete a chat and its messages"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.delete_one({"chat_id": chat_id})


def generate_response(
    prompt: str, user_id: str = "guest", chat_id: str = "default", title: str = None
):
    print(f"Processing prompt for user {user_id} in chat {chat_id}: {prompt}")
    
    try:
        # Image generation logic
        if should_generate_image(prompt):
            try:
                image_result = generate_image(prompt, user_id)
                save_conversation(user_id, chat_id, prompt, image_result["image_id"], title=title, is_image=True)
                return {
                    "type": "image",
                    "image_bytes": image_result["image_bytes"],
                    "description": image_result.get("description", ""),
                    "image_id": image_result["image_id"],
                    "content": image_result.get("description", ""),
                    "response": image_result.get("description", "")  # Ensure this exists
                }
            except Exception as e:
                error_msg = f"Failed to generate image. Error: {str(e)}"
                return {
                    "type": "text",
                    "content": error_msg,
                    "response": error_msg
                }
                
        # Normal text response flow
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        history_messages = get_chat_history(user_id, chat_id)
        llm_messages = []

        # Prepare message history
        for msg in history_messages:
            content = msg.get("prompt", "") if msg.get("sender") == "user" else msg.get("response", "")
            if not content:
                continue
                
            if msg.get("is_image", False) or msg.get("type") == "image-upload":
                if msg.get("sender") == "user":
                    llm_messages.append({
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg.get('prompt', '')}",
                    })
                else:
                    llm_messages.append({
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg.get('response', '').replace('IMAGE:', '')}",
                    })
            else:
                role = "user" if msg.get("sender") == "user" else "assistant"
                llm_messages.append({
                    "role": role,
                    "content": content
                })

        # Add current prompt
        llm_messages.append({
            "role": "user",
            "content": prompt,
        })

        try:
            # Initial LLM request
            response = requests.post(
                API_URL,
                headers=headers,
                json={
                    "model": "meta-llama/llama-4-scout-17b-16e-instruct",
                    "messages": llm_messages,
                    "temperature": 0.3,
                    "max_tokens": 2048,
                },
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
            reply = response_data["choices"][0]["message"]["content"]

            save_conversation(user_id, chat_id, prompt, reply, title=title)
            return {
                "type": "text",
                "content": reply,
                "response": reply  # Ensure this exists
            }

        except Exception as e:
            error_msg = f"Error processing your request: {str(e)}"
            print(f"API Error: {error_msg}")
            return {
                "type": "text",
                "content": error_msg,
                "response": error_msg
            }

    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        print(f"General Error: {error_msg}")
        return {
            "type": "text",
            "content": error_msg,
            "response": error_msg
        }

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel,EmailStr
from services.responder_service import generate_response, rename_chat, delete_chat, get_user_chats, get_chat_history,handle_image_upload,signup_user,login_user
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import base64
import os
from datetime import datetime
import uuid
from fastapi import UploadFile, File, Form
from typing import Annotated
from fastapi.staticfiles import StaticFiles
from typing import Optional,List

app = FastAPI()

# Create image directory if it doesn't exist
os.makedirs("image", exist_ok=True)

# Serve static files from the image directory
app.mount("/image", StaticFiles(directory="image"), name="images")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class PromptRequest(BaseModel):
    prompt: str
    user_id: str
    chat_id: str
    title: Optional[str] = None

class ChatRenameRequest(BaseModel):
    user_id: str
    chat_id: str
    new_title: str

class ChatDeleteRequest(BaseModel):
    user_id: str
    chat_id: str

class ChatHistoryRequest(BaseModel):
    user_id: str
    chat_id: str
    limit: Optional[int] = 20
    
class ImagePromptRequest(BaseModel):
    prompt: Optional[str] = None
    user_id: str
    chat_id: str

class ManualSignupRequest(BaseModel):
    username: str
    email: EmailStr
    password: str

class GoogleSignupRequest(BaseModel):
    token: str  # Google ID token

class ManualLoginRequest(BaseModel):
    email: EmailStr
    password: str

class GoogleLoginRequest(BaseModel):
    token: str

@app.post("/login")
async def login_manual(request: ManualLoginRequest):
    result = login_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=401, detail=result["message"])


@app.post("/login/google")
async def login_google(request: GoogleLoginRequest):
    result = login_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse({
            "access_token": "dummy_token",  # optional: JWT later
            "user_data": result
        })
    else:
        raise HTTPException(status_code=401, detail=result["message"])
    
@app.post("/signup")
async def signup_manual(request: ManualSignupRequest):
    result = signup_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])

@app.post("/signup/google")
async def signup_google(request: GoogleSignupRequest):
    result = signup_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])
    
@app.post("/upload-image")
async def upload_image(
    images: List[UploadFile] = File(...),
    user_id: str = Form(...),
    chat_id: str = Form(...),
    prompt: Optional[str] = Form(None),
):
    try:
        image_data_list = []
        for image in images:
            image_data = await image.read()
            image_data_list.append(image_data)

        result = handle_image_upload(
            image_data_list=image_data_list,
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt
        )

        return JSONResponse({
            "status": "success",
            "image_ids": result.get("image_ids", []),
            "image_urls": result.get("image_urls", []),
            "llm_responses": [result.get("llm_response", "")]
        })

    except Exception as e:
        import traceback
        print("Upload image error traceback:", traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

def save_image(image_bytes: bytes) -> str:
    """Save image to /image folder and return filename"""
    filename = f"img_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:4]}.png"
    filepath = os.path.join("image", filename)
    
    with open(filepath, "wb") as f:
        f.write(image_bytes)
    
    return filename

@app.post("/chat")
async def chat(request: PromptRequest):
    try:
        response = generate_response(
            prompt=request.prompt,
            user_id=request.user_id,
            chat_id=request.chat_id,
            title=request.title
        )
        
        if response.get("type") == "image":
            if response.get("error") == "rate_limit":
                return JSONResponse({
                    "type": "text",
                    "content": "I'm getting rate limited by the image generation service. Please try again in a little while."
                })
            
            filename = save_image(response["image_bytes"])
            image_url = f"/image/{filename}"
            
            return JSONResponse({
                "type": "image",
                "image_url": image_url,
                "description": response.get("description", "Generated image"),
                "image_id": response.get("image_id", "")
            })
        else:
            return JSONResponse({
                "type": "text",
                "content": response["content"]
            })
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/rename-chat")
async def rename_chat_endpoint(request: ChatRenameRequest):
    try:
        rename_chat(request.user_id, request.chat_id, request.new_title)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/delete-chat")
async def delete_chat_endpoint(request: ChatDeleteRequest):
    try:
        delete_chat(request.user_id, request.chat_id)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/get_user_chats/{user_id}")
def get_user_chats_endpoint(user_id: str):
    try:
        chats = get_user_chats(user_id)

        # Convert Mongo ObjectId and datetime to JSON serializable
        for chat in chats:
            if "_id" in chat:
                chat["_id"] = str(chat["_id"])
            if "created_at" in chat:
                chat["created_at"] = chat["created_at"].isoformat()
            if "updated_at" in chat:
                chat["updated_at"] = chat["updated_at"].isoformat()
            if "messages" in chat:
                for message in chat["messages"]:
                    if "timestamp" in message and isinstance(message["timestamp"], datetime):
                        message["timestamp"] = message["timestamp"].isoformat()
        
        return JSONResponse(content={"chats": chats}, status_code=200)
    except Exception as e:
        print("💥 Error in get_user_chats_endpoint:", e)
        return JSONResponse(content={"detail": "Failed to fetch chats"}, status_code=500)

@app.post("/get_chat_history")
async def get_chat_history_endpoint(request: ChatHistoryRequest):
    try:
        history = get_chat_history(request.user_id, request.chat_id, request.limit)
        return JSONResponse({"history": history})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))