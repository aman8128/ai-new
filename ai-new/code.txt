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 --> hugging-face

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 --> groqcloud

sk-3UnY9eVsTHi0V0NCCa5mVY61FwL4djjKakG7V3ePqs9vorgi --> stability

import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import './home.css';

function Home() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatHistory, setChatHistory] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [isSidebarVisible, setIsSidebarVisible] = useState(true);
  const messagesEndRef = useRef(null);
  const userId = useRef("user_" + Math.random().toString(36).substr(2, 9));
  const typingIntervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const botMessageIdRef = useRef(null);
  const [isTyping, setIsTyping] = useState(false);
  const inputRef = useRef(null);

  useEffect(() => {
    return () => {
      if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
    };
  }, []);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    // Create default chat on first load
    if (chatHistory.length === 0) {
      const defaultChat = {
        id: Date.now(),
        title: 'New Chat',
        messages: []
      };
      setChatHistory([defaultChat]);
      setActiveChat(defaultChat.id);
      setMessages([]);
    }
  }, []);

  const toggleSidebar = () => {
    setIsSidebarVisible(!isSidebarVisible);
  };

  const cancelRequest = () => {
    if (abortControllerRef.current) abortControllerRef.current.abort();
    if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
    botMessageIdRef.current = null;
    setIsProcessing(false);
    setIsTyping(false);
    setMessages(prev => prev.filter(msg => msg.type !== 'typing'));
  };

  const startNewChat = () => {
    if (isTyping || isProcessing) {
      alert("Please wait! AI is still typing. Let it finish before starting a new chat.");
      return;
    }

    // Check if current chat is empty
    const currentChat = chatHistory.find(chat => chat.id === activeChat);
    const isCurrentChatEmpty = currentChat?.messages?.length === 0;

    // If current chat is empty, just return to it without creating new one
    if (isCurrentChatEmpty && currentChat.title === 'New Chat') {
      setMessages([]);
      setActiveChat(currentChat.id);
      return;
    }

    // If current chat has messages, save it
    if (messages.length > 0) {
      const newChat = {
        id: Date.now(),
        title: generateChatTitle(messages),
        messages: [...messages]
      };
      setChatHistory(prev => [newChat, ...prev]);
    }

    // Check if there's already an empty chat
    const existingEmptyChat = chatHistory.find(chat => 
      chat.messages.length === 0 && chat.title === 'New Chat'
    );
    
    if (existingEmptyChat) {
      // Switch to existing empty chat
      setMessages([]);
      setActiveChat(existingEmptyChat.id);
    } else {
      // Create new empty chat
      const emptyChat = {
        id: Date.now(),
        title: "New Chat",
        messages: []
      };
      setChatHistory(prev => [emptyChat, ...prev]);
      setMessages([]);
      setActiveChat(emptyChat.id);
    }
  };

  const generateChatTitle = (messages) => {
    const firstUserMessage = messages.find(msg => msg.sender === 'user');
    if (firstUserMessage) {
      const shortText = firstUserMessage.text.replace(/\n/g, ' ').trim().slice(0, 20);
      return shortText + (firstUserMessage.text.length > 20 ? '...' : '');
    }
    return `New Chat ${new Date().toLocaleTimeString()}`;
  };

  const loadChat = (chatId) => {
    const chat = chatHistory.find(c => c.id === chatId);
    if (chat) {
      setMessages(chat.messages);
      setActiveChat(chatId);
    }
  };

  const formatMessageContent = (text) => {
    // Simple code block formatting
    const codeBlockRegex = /```(\w+)?\n([\s\S]+?)\n```/g;
    const parts = [];
    let lastIndex = 0;
    
    text.replace(codeBlockRegex, (match, language, code, offset) => {
      // Add text before code block
      if (offset > lastIndex) {
        parts.push(
          <div key={lastIndex} className="message-text">
            {text.substring(lastIndex, offset)}
          </div>
        );
      }
      
      // Add simple code block without syntax highlighting
      parts.push(
        <div key={offset} className="code-block mt-2 mb-3 p-2 bg-dark text-white rounded">
          <pre className="m-0" style={{ whiteSpace: 'pre-wrap' }}>
            <code>{code}</code>
          </pre>
        </div>
      );
      
      lastIndex = offset + match.length;
      return match;
    });
    
    // Add remaining text after last code block
    if (lastIndex < text.length) {
      parts.push(
        <div key={lastIndex} className="message-text">
          {text.substring(lastIndex)}
        </div>
      );
    }
    
    return parts.length ? parts : <div className="message-text">{text}</div>;
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!inputValue.trim() || isProcessing) return;

    const userMessage = {
      id: Date.now(),
      text: inputValue,
      type: 'text',
      sender: 'user'
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInputValue('');
    setIsProcessing(true);
    setIsTyping(true);

    const typingMessageId = Date.now() + 0.1;
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: ''
    }]);

    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt: userMessage.text, user_id: userId.current }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) throw new Error(`Server error: ${response.status}`);
      const data = await response.json();
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      const responseText = data.response || data.content || JSON.stringify(data);
      const botMessageId = Date.now() + 1;
      botMessageIdRef.current = botMessageId;

      setMessages(prev => [...prev, {
        id: botMessageId,
        type: 'text',
        sender: 'bot',
        text: ''
      }]);

      let currentIndex = 0;
      typingIntervalRef.current = setInterval(() => {
        if (currentIndex < responseText.length) {
          setMessages(prev =>
            prev.map(msg =>
              msg.id === botMessageId
                ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                : msg
            )
          );
          currentIndex++;
        } else {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
          botMessageIdRef.current = null;
          setIsTyping(false);

          const finalMessage = {
            id: botMessageId,
            type: 'text',
            sender: 'bot',
            text: responseText
          };

          if (!activeChat) {
            const title = generateChatTitle([userMessage]);
            const newChat = {
              id: Date.now(),
              title,
              messages: [userMessage, finalMessage]
            };
            setChatHistory(prev => [newChat, ...prev]);
            setActiveChat(newChat.id);
          } else {
            setChatHistory(prev =>
              prev.map(chat =>
                chat.id === activeChat
                  ? {
                      ...chat,
                      title: chat.title === 'New Chat'
                        ? generateChatTitle([userMessage])
                        : chat.title,
                      messages: [...chat.messages, userMessage, finalMessage]
                    }
                  : chat
              )
            );
          }
        }
      }, 20);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not get response from server'
        }]);
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const handleButtonClick = (e) => {
    if (isProcessing || isTyping) {
      cancelRequest();
    } else {
      handleSendMessage(e);
    }
  };

  return (
    <div className="d-flex">
      {/* Sidebar */}
      <div className={`sidebar bg-white shadow ${isSidebarVisible ? 'visible' : 'hidden'}`}>
        <div className="p-3 border-bottom">
          <button 
            onClick={startNewChat} 
            className="btn btn-outline-secondary w-100"
          >
            + New Chat
          </button>
        </div>
        <div className="p-2">
          <h6 className="px-2 py-1 text-muted">Chat History</h6>
          <div className="list-group list-group-flush">
            {chatHistory.map(chat => (
              <button
                key={chat.id}
                onClick={() => loadChat(chat.id)}
                className={`list-group-item list-group-item-action text-truncate ${activeChat === chat.id ? 'active' : ''}`}
                title={chat.title}
              >
                {chat.title}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Chat Section */}
      <div className={`flex-grow-1 d-flex flex-column vh-100 ${isSidebarVisible ? 'ms-sidebar' : ''}`}>
        <div className="bg-success text-white p-3 d-flex align-items-center justify-content-between sticky-top">
          <button className="btn btn-light me-2" onClick={toggleSidebar}>☰</button>
          <h4 className="mb-0 font-weight-bold">
            {chatHistory.find(c => c.id === activeChat)?.title || 'New Chat'}
          </h4>
          <div style={{ width: 40 }}></div>
        </div>

        <div className="flex-grow-1 overflow-auto p-3">
          <div className="d-flex flex-column gap-3">
            {messages.map((msg) => (
              <div key={msg.id} className={`d-flex ${msg.sender === 'user' ? 'justify-content-end' : 'justify-content-start'}`}>
                <div className={`p-3 rounded-3 ${msg.sender === 'user' ? 'bg-primary text-white' : msg.type === 'typing' ? 'bg-light' : 'bg-light text-dark'}`} style={{ maxWidth: '70%' }}>
                  {msg.type === 'typing' ? (
                    <div className="d-flex align-items-center gap-2">
                      <div className="spinner-grow spinner-grow-sm text-secondary" role="status">
                        <span className="visually-hidden">Typing...</span>
                      </div>
                      <span className="text-muted">Thinking...</span>
                    </div>
                  ) : (
                    <div style={{ whiteSpace: 'pre-wrap', textAlign: 'left' }}>
                      {msg.sender === 'bot' ? (
                        <div className="bot-message-content">
                          <h5 className="font-weight-bold mb-2">AI Assistant</h5>
                          {formatMessageContent(msg.text)}
                        </div>
                      ) : (
                        <div className="user-message-content">
                          <h5 className="font-weight-bold mb-2">You</h5>
                          <div className="message-text">{msg.text}</div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            ))}
            <div ref={messagesEndRef} />
          </div>
        </div>

        <form onSubmit={handleSendMessage} className="p-3 border-top">
          <div className="input-group">
            <input
              type="text"
              className="form-control rounded-pill ps-4"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={(e) => {
                if ((isProcessing || isTyping) && e.key === 'Enter') {
                  e.preventDefault();
                }
              }}
              placeholder="Type your message..."
              ref={inputRef}
            />
            <button
              type="button"
              className={`btn ms-2 rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping ? 'btn-danger' : 'btn-primary'}`}
              onClick={handleButtonClick}
              disabled={!inputValue.trim() && !(isProcessing || isTyping)}
              style={{ minWidth: '80px' }}
            >
              {(isProcessing || isTyping) ? (
                <>
                  <span className="spinner-border spinner-border-sm" role="status" />
                </>
              ) : 'Send'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

export default Home;

<button
              type="button"
              className={`btn ms-2 rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping ? 'btn-secondary' : 'btn-secondary'}`}
              onClick={handleButtonClick}
              disabled={!inputValue.trim() && !(isProcessing || isTyping)}
            >
              {(isProcessing || isTyping) ? (
                <span className="spinner-border spinner-border-sm text-light" role="status" />
              ) : 'Send'}
            </button>

<div className="bg-success text-white p-3 d-flex align-items-center justify-content-between sticky-top">
          <button className="btn btn-light me-2" onClick={toggleSidebar}>☰</button>
          <h4 className="mb-0 font-weight-bold">
            {chatHistory.find(c => c.id === activeChat)?.title || 'New Chat'}
          </h4>
          <div style={{ width: 40 }}></div>
        </div>


import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import './home.css';
import 'bootstrap-icons/font/bootstrap-icons.css';

function Home() {
  // State management
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatHistory, setChatHistory] = useState([]);
  const [archivedChats, setArchivedChats] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [isSidebarVisible, setIsSidebarVisible] = useState(true);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [chatToDelete, setChatToDelete] = useState(null);
  const [showArchived, setShowArchived] = useState(false);
  const [showRenameModal, setShowRenameModal] = useState(false);
  const [newChatTitle, setNewChatTitle] = useState('');
  const [chatToRename, setChatToRename] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  
  // Refs
  const messagesEndRef = useRef(null);
  const userId = useRef("user_" + Math.random().toString(36).substr(2, 9));
  const typingIntervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const botMessageIdRef = useRef(null);
  const inputRef = useRef(null);
  const sidebarRef = useRef(null);

  // Constants
  const TOAST_DURATION = 3000;
  const TYPING_SPEED = 20; // milliseconds per character

  // Toast container style
  const toastContainerStyle = {
    position: 'fixed',
    top: '20px',
    right: '20px',
    zIndex: 1100,
    display: 'flex',
    flexDirection: 'column',
    gap: '10px'
  };

  // Effects
  useEffect(() => {
    // Cleanup on unmount
    return () => {
      if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
    };
  }, []);

  useEffect(() => {
    // Scroll to bottom when messages change
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    // Focus input when not processing
    if (!isProcessing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isProcessing]);

  useEffect(() => {
    // Initialize with default chat if empty
    if (chatHistory.length === 0) {
      const defaultChat = {
        id: Date.now(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory([defaultChat]);
      setActiveChat(defaultChat.id);
    }
  }, []);

  useEffect(() => {
    // Close sidebar when clicking outside
    const handleClickOutside = (event) => {
      if (sidebarRef.current && !sidebarRef.current.contains(event.target)) {
        if (window.innerWidth < 768) {
          setIsSidebarVisible(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Helper functions
  const showToast = (type, message) => {
    const toastElement = document.getElementById(`${type}Toast`);
    if (toastElement) {
      const toast = new window.bootstrap.Toast(toastElement, {
        delay: TOAST_DURATION
      });
      toast.show();
    }
  };

  const generateChatTitle = (messages) => {
    const firstUserMessage = messages.find(msg => msg.sender === 'user');
    if (firstUserMessage) {
      const shortText = firstUserMessage.text
        .replace(/\n/g, ' ')
        .trim()
        .slice(0, 30);
      return shortText + (firstUserMessage.text.length > 30 ? '...' : '');
    }
    return `New Chat ${new Date().toLocaleTimeString()}`;
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
    });
  };

  // Chat operations
  const toggleSidebar = () => setIsSidebarVisible(!isSidebarVisible);

  const cancelRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      showToast('info', 'Request cancelled');
    }
    if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
    botMessageIdRef.current = null;
    setIsProcessing(false);
    setIsTyping(false);
    setMessages(prev => prev.filter(msg => msg.type !== 'typing'));
  };

  const startNewChat = () => {
    if (isTyping || isProcessing) {
      showToast('warning', 'Please wait for the current response to finish');
      return;
    }

    const emptyChat = chatHistory.find(chat => chat.messages.length === 0);
    if (emptyChat) {
      setActiveChat(emptyChat.id);
      setMessages([]);
    } else {
      const currentChat = chatHistory.find(chat => chat.id === activeChat);
      const hasBotMessage = messages.some(msg => msg.sender === 'bot');

      if (currentChat && hasBotMessage) {
        const updatedChat = {
          ...currentChat,
          messages: [...messages],
          title: currentChat.title === 'New Chat' ? generateChatTitle(messages) : currentChat.title,
          updatedAt: new Date().toISOString()
        };

        const updatedHistory = chatHistory.map(chat =>
          chat.id === activeChat ? updatedChat : chat
        );
        setChatHistory(updatedHistory);
      }

      const newChat = {
        id: Date.now(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory(prev => [newChat, ...prev]);
      setMessages([]);
      setActiveChat(newChat.id);
    }
  };

  const loadChat = (chatId) => {
    const chat = [...chatHistory, ...archivedChats].find(c => c.id === chatId);
    if (chat) {
      setMessages(chat.messages);
      setActiveChat(chatId);
      
      // Close sidebar on mobile
      if (window.innerWidth < 768) {
        setIsSidebarVisible(false);
      }
    }
  };

  const handleShare = async (chatId) => {
    const chat = [...chatHistory, ...archivedChats].find(c => c.id === chatId);
    if (!chat) return;

    try {
      const content = chat.messages.map(msg => 
        `${msg.sender === 'user' ? 'You' : 'Assistant'}: ${msg.text}`
      ).join('\n\n');
      
      await navigator.clipboard.writeText(content);
      showToast('success', 'Chat copied to clipboard!');
    } catch (err) {
      showToast('error', 'Failed to copy chat');
    }
  };

  const handleArchive = (chatId) => {
    const chat = chatHistory.find(c => c.id === chatId);
    if (!chat) return;

    setArchivedChats(prev => [{
      ...chat,
      archivedAt: new Date().toISOString()
    }, ...prev]);
    setChatHistory(prev => prev.filter(c => c.id !== chatId));
    
    if (activeChat === chatId) {
      setMessages([]);
      setActiveChat(null);
    }
    
    showToast('success', 'Chat has been archived');
  };

  const handleUnarchive = (chatId) => {
    const chat = archivedChats.find(c => c.id === chatId);
    if (!chat) return;

    setChatHistory(prev => [{
      ...chat,
      archivedAt: undefined
    }, ...prev]);
    setArchivedChats(prev => prev.filter(c => c.id !== chatId));
    
    showToast('success', 'Chat has been unarchived');
  };

  const confirmDelete = (chatId) => {
    setChatToDelete(chatId);
    setShowDeleteModal(true);
  };

  const handleDelete = () => {
    if (!chatToDelete) return;
    
    const updatedHistory = chatHistory.filter(chat => chat.id !== chatToDelete);
    const updatedArchived = archivedChats.filter(chat => chat.id !== chatToDelete);
    
    setChatHistory(updatedHistory);
    setArchivedChats(updatedArchived);
    
    if (activeChat === chatToDelete) {
      setMessages([]);
      setActiveChat(null);
    }
    
    setShowDeleteModal(false);
    setChatToDelete(null);
    
    showToast('success', 'Chat has been deleted');
  };

  const confirmRename = (chatId, currentTitle) => {
    setChatToRename(chatId);
    setNewChatTitle(currentTitle);
    setShowRenameModal(true);
  };

  const handleRename = () => {
    if (!chatToRename || !newChatTitle.trim()) return;
    
    setChatHistory(prev =>
      prev.map(chat =>
        chat.id === chatToRename
          ? { ...chat, title: newChatTitle, updatedAt: new Date().toISOString() }
          : chat
      )
    );
    
    setArchivedChats(prev =>
      prev.map(chat =>
        chat.id === chatToRename
          ? { ...chat, title: newChatTitle, updatedAt: new Date().toISOString() }
          : chat
      )
    );
    
    setShowRenameModal(false);
    setChatToRename(null);
    setNewChatTitle('');
    
    showToast('success', 'Chat title updated');
  };

  const formatMessageContent = (text) => {
    if (!text) return null;
    
    const paragraphs = text.split('\n\n');
    return paragraphs.map((paragraph, index) => {
      if (paragraph.trim() === '') return null;
      
      // Heading detection
      if (paragraph.trim().endsWith(':')) {
        return <h6 key={index} className="message-heading">{paragraph}</h6>;
      }
      
      // Code block detection
      if (paragraph.startsWith('```') && paragraph.endsWith('```')) {
        const code = paragraph.slice(3, -3).trim();
        return (
          <div key={index} className="code-block">
            <pre><code>{code}</code></pre>
          </div>
        );
      }
      
      // List detection
      if (paragraph.startsWith('- ') || paragraph.startsWith('* ')) {
        const items = paragraph.split('\n');
        return (
          <ul key={index} className="message-list">
            {items.map((item, i) => (
              <li key={i}>{item.replace(/^[-*] /, '')}</li>
            ))}
          </ul>
        );
      }
      
      // Numbered list detection
      if (/^\d+\.\s/.test(paragraph)) {
        const items = paragraph.split('\n');
        return (
          <ol key={index} className="message-list">
            {items.map((item, i) => (
              <li key={i}>{item.replace(/^\d+\.\s/, '')}</li>
            ))}
          </ol>
        );
      }
      
      // Default paragraph
      return <p key={index} className="message-paragraph">{paragraph}</p>;
    });
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!inputValue.trim() || isProcessing) return;

    const userMessage = {
      id: Date.now(),
      text: inputValue,
      type: 'text',
      sender: 'user',
      timestamp: new Date().toISOString()
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInputValue('');
    setIsProcessing(true);
    setIsTyping(true);

    const typingMessageId = Date.now() + 0.1;
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: '',
      timestamp: new Date().toISOString()
    }]);

    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({ 
          prompt: userMessage.text, 
          user_id: userId.current,
          chat_id: activeChat
        }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }

      const data = await response.json();
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      const responseText = data.response || data.content || JSON.stringify(data);
      const botMessageId = Date.now() + 1;
      botMessageIdRef.current = botMessageId;

      setMessages(prev => [...prev, {
        id: botMessageId,
        type: 'text',
        sender: 'bot',
        text: '',
        timestamp: new Date().toISOString()
      }]);

      let currentIndex = 0;
      typingIntervalRef.current = setInterval(() => {
        if (currentIndex < responseText.length) {
          setMessages(prev =>
            prev.map(msg =>
              msg.id === botMessageId
                ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                : msg
            )
          );
          currentIndex++;
        } else {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
          botMessageIdRef.current = null;
          setIsTyping(false);

          const finalMessage = {
            id: botMessageId,
            type: 'text',
            sender: 'bot',
            text: responseText,
            timestamp: new Date().toISOString()
          };

          if (!activeChat) {
            const title = generateChatTitle([userMessage]);
            const newChat = {
              id: Date.now(),
              title,
              messages: [userMessage, finalMessage],
              createdAt: new Date().toISOString()
            };
            setChatHistory(prev => [newChat, ...prev]);
            setActiveChat(newChat.id);
          } else {
            setChatHistory(prev =>
              prev.map(chat =>
                chat.id === activeChat
                  ? {
                      ...chat,
                      title: chat.title === 'New Chat'
                        ? generateChatTitle([userMessage])
                        : chat.title,
                      messages: [...chat.messages, userMessage, finalMessage],
                      updatedAt: new Date().toISOString()
                    }
                  : chat
              )
            );
          }
        }
      }, TYPING_SPEED);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: Date.now(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not get response from server. Please try again.',
          timestamp: new Date().toISOString()
        }]);
        showToast('error', 'Failed to get response from server');
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const handleButtonClick = (e) => {
    if (isProcessing || isTyping) {
      cancelRequest();
    } else {
      handleSendMessage(e);
    }
  };

  const handleChatClick = (e, chatId) => {
    e.preventDefault();
    e.stopPropagation();
    loadChat(chatId);
  };

  // Filter chats based on search query
  const filteredChats = (chats) => {
    return chats.filter(chat => 
      chat.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      chat.messages.some(msg => 
        msg.text.toLowerCase().includes(searchQuery.toLowerCase())
      )
    );
  };

  return (
    <div className="d-flex vh-100">
      {/* Delete Confirmation Modal */}
      <div className={`modal fade ${showDeleteModal ? 'show' : ''}`} 
           style={{ display: showDeleteModal ? 'block' : 'none' }} 
           tabIndex="-1">
        <div className="modal-dialog modal-dialog-centered">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title">Confirm Deletion</h5>
              <button type="button" className="btn-close" onClick={() => setShowDeleteModal(false)}></button>
            </div>
            <div className="modal-body">
              <p>Are you sure you want to delete this chat? This action cannot be undone.</p>
            </div>
            <div className="modal-footer">
              <button type="button" className="btn btn-outline-secondary" onClick={() => setShowDeleteModal(false)}>Cancel</button>
              <button type="button" className="btn btn-danger" onClick={handleDelete}>
                <i className="bi bi-trash me-1"></i> Delete
              </button>
            </div>
          </div>
        </div>
      </div>
      {showDeleteModal && <div className="modal-backdrop fade show"></div>}

      {/* Rename Modal */}
      <div className={`modal fade ${showRenameModal ? 'show' : ''}`} 
           style={{ display: showRenameModal ? 'block' : 'none' }} 
           tabIndex="-1">
        <div className="modal-dialog modal-dialog-centered">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title">Rename Chat</h5>
              <button type="button" className="btn-close" onClick={() => setShowRenameModal(false)}></button>
            </div>
            <div className="modal-body">
              <input
                type="text"
                className="form-control"
                value={newChatTitle}
                onChange={(e) => setNewChatTitle(e.target.value)}
                placeholder="Enter new chat title"
                autoFocus
              />
            </div>
            <div className="modal-footer">
              <button type="button" className="btn btn-outline-secondary" onClick={() => setShowRenameModal(false)}>Cancel</button>
              <button type="button" className="btn btn-primary" onClick={handleRename}>
                <i className="bi bi-check2 me-1"></i> Save
              </button>
            </div>
          </div>
        </div>
      </div>
      {showRenameModal && <div className="modal-backdrop fade show"></div>}

      {/* Toast Notifications */}
      <div style={toastContainerStyle}>
        <div id="successToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-success text-white">
            <strong className="me-auto">Success</strong>
            <button type="button" className="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>

        <div id="errorToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-danger text-white">
            <strong className="me-auto">Error</strong>
            <button type="button" className="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>

        <div id="warningToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-warning text-dark">
            <strong className="me-auto">Warning</strong>
            <button type="button" className="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>

        <div id="infoToast" className="toast" role="alert" aria-live="assertive" aria-atomic="true">
          <div className="toast-header bg-info text-white">
            <strong className="me-auto">Info</strong>
            <button type="button" className="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div className="toast-body"></div>
        </div>
      </div>

      {/* Sidebar */}
      <div 
        ref={sidebarRef}
        className={`sidebar bg-white shadow-sm ${isSidebarVisible ? 'visible' : 'hidden'}`}
      >
        <div className="p-3 border-bottom">
          <button
            onClick={startNewChat}
            className="btn btn-outline-secondary w-70 d-flex align-items-center justify-content-center gap-2"
            disabled={isTyping || isProcessing}
          >
            <i className="bi bi-plus-lg"></i>
            <span>New Chat</span>
          </button>
        </div>
        
        <div className="p-3 border-bottom">
          <div className="input-group">
            <span className="input-group-text bg-white">
              <i className="bi bi-search"></i>
            </span>
            <input
              type="text"
              className="form-control"
              placeholder="Search chats..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
            {searchQuery && (
              <button
                className="btn btn-outline-secondary"
                type="button"
                onClick={() => setSearchQuery('')}
              >
                <i className="bi bi-x"></i>
              </button>
            )}
          </div>
        </div>
        
        <div className="p-3">
          <div className="d-flex justify-content-between align-items-center mb-2">
            <h6 className="text-muted mb-0">
              {showArchived ? 'Archived Chats' : 'Recent Chats'}
            </h6>
            <button 
              className="btn btn-sm btn-outline-secondary"
              onClick={() => setShowArchived(!showArchived)}
              title={showArchived ? 'Show active chats' : 'Show archived chats'}
            >
              {showArchived ? (
                <i className="bi bi-inbox"></i>
              ) : (
                <i className="bi bi-archive"></i>
              )}
            </button>
          </div>
          
          <div className="list-group list-group-flush chat-list">
            {filteredChats(showArchived ? archivedChats : chatHistory).length === 0 ? (
              <div className="text-muted p-3 text-center">
                <i className="bi bi-chat-square-text fs-4 mb-2 d-block"></i>
                No {showArchived ? 'archived' : 'active'} chats found
              </div>
            ) : (
              filteredChats(showArchived ? archivedChats : chatHistory)
                .sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt))
                .map(chat => (
                <div 
                  key={chat.id} 
                  className={`list-group-item list-group-item-action px-3 py-2 ${activeChat === chat.id ? 'active' : ''}`}
                  onClick={(e) => handleChatClick(e, chat.id)}
                >
                  <div className="d-flex justify-content-between align-items-start">
                    <div className="flex-grow-1 me-2" style={{ minWidth: 0 }}>
                      <div className="d-flex justify-content-between align-items-center">
                        <h6 
                          className="mb-0 text-truncate" 
                          style={{ maxWidth: '180px' }}
                          title={chat.title}
                        >
                          {chat.title}
                        </h6>
                        {chat.archivedAt && (
                          <span className="badge bg-secondary ms-2">Archived</span>
                        )}
                      </div>
                      <small className="text-muted">
                        {formatDate(chat.updatedAt || chat.createdAt)}
                      </small>
                    </div>

                    <div className="dropdown">
                      <button 
                        className="btn btn-sm btn-outline-secondary border-0 p-1"
                        type="button" 
                        data-bs-toggle="dropdown" 
                        aria-expanded="false"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <i className="bi bi-three-dots-vertical"></i>
                      </button>
                      <ul className="dropdown-menu dropdown-menu-end shadow-sm">
                        <li>
                          <button 
                            className="dropdown-item" 
                            onClick={(e) => {
                              e.preventDefault();
                              confirmRename(chat.id, chat.title);
                            }}
                          >
                            <i className="bi bi-pencil me-2"></i>Rename
                          </button>
                        </li>
                        <li>
                          <button 
                            className="dropdown-item" 
                            onClick={(e) => {
                              e.preventDefault();
                              handleShare(chat.id);
                            }}
                          >
                            <i className="bi bi-share me-2"></i>Share
                          </button>
                        </li>
                        {showArchived ? (
                          <li>
                            <button 
                              className="dropdown-item" 
                              onClick={(e) => {
                                e.preventDefault();
                                handleUnarchive(chat.id);
                              }}
                            >
                              <i className="bi bi-inbox me-2"></i>Unarchive
                            </button>
                          </li>
                        ) : (
                          <li>
                            <button 
                              className="dropdown-item" 
                              onClick={(e) => {
                                e.preventDefault();
                                handleArchive(chat.id);
                              }}
                            >
                              <i className="bi bi-archive me-2"></i>Archive
                            </button>
                          </li>
                        )}
                        <li><hr className="dropdown-divider" /></li>
                        <li>
                          <button 
                            className="dropdown-item text-danger" 
                            onClick={(e) => {
                              e.preventDefault();
                              confirmDelete(chat.id);
                            }}
                          >
                            <i className="bi bi-trash me-2"></i>Delete
                          </button>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className={`flex-grow-1 d-flex flex-column ${isSidebarVisible ? 'ms-sidebar' : ''}`}>
        {/* Header */}
        <header className="bg-primary text-white p-3 d-flex align-items-center justify-content-between sticky-top shadow-sm">
          <button 
            className="btn btn-light btn-sm me-2" 
            onClick={toggleSidebar}
            aria-label={isSidebarVisible ? 'Close sidebar' : 'Open sidebar'}
          >
            {isSidebarVisible ? (
              <i className="bi bi-x-lg"></i>
            ) : (
              <i className="bi bi-list"></i>
            )}
          </button>
          <h4 className="mb-0 fw-semibold text-truncate flex-grow-1 text-center">
            {[...chatHistory, ...archivedChats].find(c => c.id === activeChat)?.title || 'New Chat'}
          </h4>
          <div style={{ width: 40 }}></div>
        </header>

        {/* Messages Area */}
        <main className="flex-grow-1 overflow-auto p-3 bg-light">
          <div className="d-flex flex-column gap-3">
            {messages.length === 0 ? (
              <div className="text-center mt-5">
                <div className="mb-4">
                  <i className="bi bi-chat-square-text fs-1 text-muted"></i>
                </div>
                <h5 className="text-muted">Start a new conversation</h5>
                <p className="text-muted">Type a message below to begin chatting</p>
              </div>
            ) : (
              messages.map((msg) => (
                <div 
                  key={msg.id} 
                  className={`d-flex ${msg.sender === 'user' ? 'justify-content-end' : 'justify-content-start'}`}
                >
                  <div 
                    className={`message-container p-3 rounded-3 ${msg.sender === 'user' ? 'bg-primary text-white' : msg.type === 'typing' ? 'bg-white' : 'bg-white text-dark shadow-sm'}`}
                    style={{ maxWidth: '85%' }}
                  >
                    {msg.type === 'typing' ? (
                      <div className="d-flex align-items-center gap-2">
                        <div className="spinner-grow spinner-grow-sm text-secondary" role="status" />
                        <span className="text-muted">Thinking...</span>
                      </div>
                    ) : (
                      <div className="message-content">
                        {msg.sender === 'bot'
                          ? <div className="bot-message">{formatMessageContent(msg.text)}</div>
                          : <div className="user-message">{msg.text.split('\n').map((line, i) => <p key={i} className="mb-0">{line}</p>)}</div>
                        }
                      </div>
                    )}
                    <div className="text-end mt-1">
                      <small className={`text-opacity-75 ${msg.sender === 'user' ? 'text-white' : 'text-muted'}`}>
                        {new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                      </small>
                    </div>
                  </div>
                </div>
              ))
            )}
            <div ref={messagesEndRef} />
          </div>
        </main>

        {/* Input Area */}
        <footer className="p-3 border-top bg-white">
          <form onSubmit={handleSendMessage}>
            <div className="input-group">
              <input
                type="text"
                className="form-control rounded-pill ps-3 pe-5"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage(e);
                  }
                }}
                placeholder="Type your message..."
                ref={inputRef}
                disabled={isProcessing || isTyping}
                aria-label="Type your message"
              />
              <button
                type="button"
                className={`btn ms-2 rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping ? 'btn-secondary' : 'btn-secondary'}`}
                onClick={handleButtonClick}
                disabled={!inputValue.trim() && !(isProcessing || isTyping)}
              >
                {(isProcessing || isTyping) ? (
                  <span className="spinner-border spinner-border-sm text-light" role="status" />
                ) : 'Send'}
              </button>
            </div>
            <div className="text-center mt-2">
              <small className="text-muted">
                {isProcessing || isTyping ? (
                  <button 
                    type="button" 
                    className="btn btn-sm btn-outline-danger"
                    onClick={cancelRequest}
                  >
                    <i className="bi bi-stop-circle me-1"></i> Stop Generating
                  </button>
                ) : (
                  'Press Enter to send, Shift+Enter for new line'
                )}
              </small>
            </div>
          </form>
        </footer>
      </div>
    </div>
  );
}

export default Home;


