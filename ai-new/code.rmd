responder_service.py :

import requests
from datetime import datetime
from pymongo import MongoClient
from duckduckgo_search import DDGS
import base64
from bson.binary import Binary
from io import BytesIO
import uuid
from PIL import Image
from bson import ObjectId
import os
from tempfile import NamedTemporaryFile
from typing import Union
import tempfile
from services.utils import save_image
import bcrypt
from google.oauth2 import id_token
from google.auth.transport import requests as google_requests

# Configuration
GROQ_API_KEY = "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"
STABILITY_API_KEY = "sk-3UnY9eVsTHi0V0NCCa5mVY61FwL4djjKakG7V3ePqs9vorgi"
API_URL = "https://api.groq.com/openai/v1/chat/completions"
STABILITY_API_URL = (
    "https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image"
)

# MongoDB setup
client = MongoClient("mongodb://localhost:27017/")
db = client["ai_new"]


uploaded_images_collection = db["uploaded_images"]
users_collection = db["users"]

user_info_collection = db["user_info"] 

def get_generated_images_collection():
    return db["uploaded_images"]

def save_uploaded_image(image_data: Union[bytes, str], user_id: str) -> str:
    """Save uploaded image (either bytes or base64) and return file path"""
    try:
        # Create user-specific directory if it doesn't exist
        user_dir = os.path.join(IMAGE_UPLOAD_DIR, user_id)
        os.makedirs(user_dir, exist_ok=True)

        # Generate unique filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"upload_{timestamp}_{uuid.uuid4().hex[:8]}.png"
        filepath = os.path.join(user_dir, filename)

        # Handle both base64 and raw bytes
        if isinstance(image_data, str):
            # Assume it's base64 if it's a string
            if image_data.startswith("data:image"):
                # Strip data URL prefix if present
                image_data = image_data.split(",", 1)[1]
            image_bytes = base64.b64decode(image_data)
        else:
            image_bytes = image_data

        # Save the image
        with open(filepath, "wb") as f:
            f.write(image_bytes)

        return filepath
    except Exception as e:
        print(f"Error saving uploaded image: {e}")
        raise

def process_image_with_llm(
    image_paths: list[str], prompt: str = None, history: list = None
) -> str:
    print("📤 Sending multiple images to LLM with prompt:", prompt)

    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    # Encode images
    image_parts = [
        {
            "type": "image_url",
            "image_url": {
                "url": f"data:image/png;base64,{base64.b64encode(open(p, 'rb').read()).decode('utf-8')}"
            },
        }
        for p in image_paths
    ]

    # Convert previous text + image history
    llm_messages = []
    if history:
        for msg in history:
            if msg.get("is_image", False):
                llm_messages.append(
                    {
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg['prompt']}",
                    }
                )
                llm_messages.append(
                    {
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg['response'].replace('IMAGE:', '')}",
                    }
                )
            else:
                llm_messages.append({"role": "user", "content": msg["prompt"]})
                llm_messages.append({"role": "assistant", "content": msg["response"]})

    # Add current image + prompt
    llm_messages.append(
        {"role": "user", "content": [{"type": "text", "text": prompt}] + image_parts}
    )

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": llm_messages,
        "max_tokens": 1500,
    }

    try:
        print("⏳ Requesting LLM...")
        response = requests.post(API_URL, headers=headers, json=data, timeout=60)
        print("✅ Response status:", response.status_code)
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    except Exception as e:
        print(f"❌ Error in LLM call: {e}")
        raise

def signup_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            # Google Sign-In case
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())
                
                # Extract all available Google profile information
                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),  # Profile picture URL
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")  # Unique Google ID
                }

                # Check if user already exists
                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success", 
                        "message": "User already exists", 
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create comprehensive user document
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,  # Store all Google data
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }
                
                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success", 
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Normal signup case (unchanged)
            username = data.get("username")
            email = data.get("email")
            password = data.get("password")

            if not all([username, email, password]):
                return {"status": "error", "message": "Missing fields"}

            if user_info_collection.find_one({"email": email}):
                return {"status": "error", "message": "Email already registered"}
            
            user_doc = {
                "username": username,
                "email": email,
                "password": password,
                "auth_type": "manual",
                "created_at": datetime.utcnow(),
                "last_login": datetime.utcnow()
            }
            inserted = user_info_collection.insert_one(user_doc)
            return {"status": "success", "user_id": str(inserted.inserted_id)}

    except Exception as e:
        print(f"Signup error: {e}")
        return {"status": "error", "message": str(e)}
    
def login_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())

                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")
                }

                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success",
                        "message": "User already exists (logged in)",
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create account if not exist
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }

                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success",
                    "message": "New Google user created",
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Manual login
            email = data.get("email")
            password = data.get("password")

            if not all([email, password]):
                return {"status": "error", "message": "Missing fields"}

            user = user_info_collection.find_one({"email": email, "auth_type": "manual"})
            if not user:
                return {"status": "error", "message": "User not found"}

            if user["password"] != password:
                return {"status": "error", "message": "Incorrect password"}

            return {
                "status": "success",
                "message": "Login successful",
                "user_id": str(user["_id"]),
                "profile_data": {
                    "email": user["email"],
                    "username": user["username"],
                }
            }

    except Exception as e:
        return {"status": "error", "message": str(e)}

def handle_image_upload(image_data_list, user_id, chat_id, prompt=None):
    try:
        image_urls = []
        image_ids = []
        image_binaries = []
        temp_file_paths = []

        # Save and collect info
        for image_data in image_data_list:
            filename = save_image(image_data)
            image_url = f"/image/{filename}"
            image_urls.append(image_url)
            image_ids.append(str(uuid.uuid4()))
            image_binaries.append(Binary(image_data))

            # Save temp file for LLM
            with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp_file:
                tmp_file.write(image_data)
                temp_file_paths.append(tmp_file.name)

        # 🔥 Send to LLM with all image paths
        llm_response = None
        if prompt:
            history_messages = get_chat_history(user_id, chat_id)
            llm_response = process_image_with_llm(
                temp_file_paths, prompt, history=history_messages
            )

        # Clean up temp files
        for path in temp_file_paths:
            try:
                os.remove(path)
            except:
                pass

        # Save to uploaded_images collection
        image_doc = {
            "user_id": user_id,
            "chat_id": chat_id,
            "prompt": prompt,
            "image_data": image_binaries,
            "image_urls": image_urls,
            "image_ids": image_ids,
            "created_at": datetime.utcnow(),
        }
        uploaded_images_collection.insert_one(image_doc)

        # Get or create user's chat collection
        user_chats_col = get_user_conversations_collection(user_id)
        
        # Check if chat exists
        chat = user_chats_col.find_one({"chat_id": chat_id})
        
        if not chat:
            # Create new chat document
            chat_title = prompt[:50] + "..." if prompt and len(prompt) > 50 else prompt or "Image Upload"
            chat_doc = {
                "chat_id": chat_id,
                "user_id": user_id,
                "title": chat_title,
                "created_at": datetime.utcnow(),
                "updated_at": datetime.utcnow(),
                "messages": []
            }
            user_chats_col.insert_one(chat_doc)
        
        # Create message to save in chat
        message = {
            "message_id": str(ObjectId()),
            "sender": "user",
            "type": "image-upload",
            "prompt": prompt or "",
            "image_urls": image_urls,
            "image_ids": image_ids,
            "timestamp": datetime.utcnow(),
            "llm_response": llm_response,
            "is_image": True
        }

        # Update chat with new message
        user_chats_col.update_one(
            {"chat_id": chat_id},
            {
                "$push": {"messages": message},
                "$set": {"updated_at": datetime.utcnow()}
            }
        )

        return {
            "status": "success",
            "image_ids": image_ids,
            "image_urls": image_urls,
            "message": "Images uploaded successfully",
            "llm_response": llm_response,
        }

    except Exception as e:
        print(f"Error in handle_image_upload (batch): {str(e)}")
        return {"status": "error", "error": str(e)}

def get_user_conversations_collection(user_id: str):
    """Get or create a conversations collection for a specific user"""
    return db[f"{user_id}"]

def users_info(user_id: str):
    chats_collection = get_user_conversations_collection(user_id)
    
    chat_docs = chats_collection.find({}, {"chat_id": 1, "title": 1, "created_at": 1,"messages":1})
    
    return chat_docs


def get_generated_images_collection():
    """Get the global generated images collection"""
    return db["generated_images"]


def search_web(query: str) -> str:
    print("Searching the web for: ", query)
    results = []
    with DDGS() as ddgs:
        for r in ddgs.text(query, max_results=10):
            snippet = f"{r['title']}: {r['body']}"
            results.append(snippet)
    return "\n".join(results)


def should_generate_image(prompt: str) -> bool:
    """Use the LLM to determine if the prompt is requesting an image generation"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the following user prompt to determine if the user is requesting an image to be generated.

    User Prompt: "{prompt}"

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.5,
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining image generation need: {e}")
        return False

def generate_image(prompt: str, user_id: str) -> dict:
    """Generate an image using Stability AI's API"""
    print(f"Generating image for prompt: {prompt}")
    
    headers = {
        "Authorization": f"Bearer {STABILITY_API_KEY}",
        "Content-Type": "application/json"
    }
    
    data = {
        "text_prompts": [{"text": prompt, "weight": 1}],
        "cfg_scale": 7,
        "height": 1024,
        "width": 1024,
        "samples": 1,
        "steps": 30,
    }
    
    try:
        response = requests.post(STABILITY_API_URL, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        response_data = response.json()
        
        if not response_data.get("artifacts"):
            raise Exception("No image artifacts in response")
            
        image_data = response_data["artifacts"][0]["base64"]
        image_bytes = base64.b64decode(image_data)
        
        # Save image information to the global images collection
        images_col = get_generated_images_collection()
        image_doc = {
            "user_id": user_id,
            "prompt": prompt,
            "generated_at": datetime.utcnow(),
            "model": "stable-diffusion-xl-1024-v1-0",
            "image_data": image_data  # Storing base64 for simplicity
        }
        image_id = images_col.insert_one(image_doc).inserted_id
        
        return {
            "type": "image",
            "image_bytes": image_bytes,
            "description": f"Generated image based on: '{prompt}'",
            "image_id": str(image_id)
        }
    except Exception as e:
        print(f"Image generation failed: {e}")
        raise

def should_perform_search(prompt: str, model_response: str) -> bool:
    """Determine if a web search is truly needed for this prompt"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the user's prompt and decide if a web search is ABSOLUTELY NECESSARY to answer correctly.
    Web search should ONLY be performed if:
    1. The question is about very recent events (last few days/weeks)
    2. The question requires real-time data (stock prices, sports scores, etc.)
    3. Your initial response indicates you don't know the answer
    4. The question is about specific facts not in your training data (after 2023)

    User Prompt: "{prompt}"
    Your Initial Response: "{model_response}"

    If any of the above conditions are met, respond with 'YES'.
    Otherwise, respond with 'NO'.

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.1,  # Lower temperature for more deterministic responses
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining search need: {e}")
        return False  # Default to no search if there's an error


def save_conversation(
    user_id: str,
    chat_id: str,
    prompt: str,
    response: str,
    title: str = None,
    is_image: bool = False,
    image_urls: list = None,
    image_ids: list = None
):
    """Save conversation with title handling"""
    conversations_col = get_user_conversations_collection(user_id)

    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat:
        # New chat - use provided title or generate from prompt
        chat_title = (
            title
            if title
            else f"Chat: {prompt[:30]}..." if len(prompt) > 30 else f"Chat: {prompt}"
        )
        chat_doc = {
            "chat_id": chat_id,
            "user_id": user_id,
            "title": chat_title,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "messages": [],
        }
        conversations_col.insert_one(chat_doc)

    # Add message
    message = {
        "message_id": str(ObjectId()),
        "timestamp": datetime.utcnow(),
        "prompt": prompt,
        "is_image": is_image,
    }

    if is_image:
        message.update({
            "type": "image-upload",
            "image_urls": image_urls,
            "image_ids": image_ids,
            "response": f"IMAGE:{response}" if response else None
        })
    else:
        message.update({
            "type": "text",
            "response": response
        })

    conversations_col.update_one(
        {"chat_id": chat_id},
        {
            "$push": {"messages": message},
            "$set": {"updated_at": datetime.utcnow()}
        }
    )

    print(f"Saved conversation for user {user_id} in chat {chat_id}")

def get_chat_history(user_id: str, chat_id: str, limit: int = 15):
    """Get the conversation history for a specific chat"""
    conversations_col = get_user_conversations_collection(user_id)
    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat or "messages" not in chat:
        return []

    # Return the most recent messages up to the limit
    return chat["messages"][-limit:]

def get_user_chats(user_id: str):
    conversations_col = get_user_conversations_collection(user_id)
    return list(
        conversations_col.find(
            {}, {"chat_id": 1, "title": 1, "created_at": 1, "updated_at": 1, "messages": 1}
        )
    )

def rename_chat(user_id: str, chat_id: str, new_title: str):
    """Rename a chat"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$set": {"title": new_title, "updated_at": datetime.utcnow()}},
    )


def delete_chat(user_id: str, chat_id: str):
    """Delete a chat and its messages"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.delete_one({"chat_id": chat_id})


def generate_response(
    prompt: str, user_id: str = "guest", chat_id: str = "default", title: str = None
):
    print(f"Processing prompt for user {user_id} in chat {chat_id}: {prompt}")
    
    try:
        # Image generation logic
        if should_generate_image(prompt):
            try:
                image_result = generate_image(prompt, user_id)
                save_conversation(
                    user_id=user_id,
                    chat_id=chat_id,
                    prompt=prompt,
                    response=image_result["image_id"],
                    title=title,
                    is_image=True
                )
                return image_result
            except Exception as e:
                error_msg = f"Failed to generate image. Error: {str(e)}"
                save_conversation(
                    user_id=user_id,
                    chat_id=chat_id,
                    prompt=prompt,
                    response=error_msg,
                    title=title
                )
                return {
                    "type": "text",
                    "content": error_msg
                }
                
        # Normal text response flow
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        history_messages = get_chat_history(user_id, chat_id)

        # Prepare the message history for the LLM
        llm_messages = []
        for msg in history_messages:
            if msg.get("is_image", False):
                llm_messages.append({
                    "role": "user",
                    "content": f"(Image Upload)\nPrompt: {msg.get('prompt', '')}"
                })
                if msg.get("response"):
                    llm_messages.append({
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg['response'].replace('IMAGE:', '')}"
                    })
            else:
                if msg.get("prompt"):
                    llm_messages.append({
                        "role": "user", 
                        "content": msg["prompt"]
                    })
                if msg.get("response"):
                    llm_messages.append({
                        "role": "assistant",
                        "content": msg["response"]
                    })

        # Add the current prompt
        llm_messages.append({
            "role": "user",
            "content": prompt
        })

        data = {
            "model": "meta-llama/llama-4-scout-17b-16e-instruct",
            "messages": llm_messages,
            "temperature": 0.3,
            "max_tokens": 2048,
        }

        response = requests.post(API_URL, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        result = response.json()
        reply = result["choices"][0]["message"]["content"]

        # Save the conversation
        save_conversation(
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt,
            response=reply,
            title=title
        )

        return {
            "type": "text",
            "content": reply
        }

    except requests.exceptions.RequestException as e:
        error_msg = f"API request failed: {str(e)}"
        print(f"Error in text generation: {error_msg}")
        save_conversation(
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt,
            response=error_msg,
            title=title
        )
        return {
            "type": "text",
            "content": error_msg
        }
    except Exception as e:
        error_msg = f"Error processing your request: {str(e)}"
        print(f"Error in text generation: {error_msg}")
        save_conversation(
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt,
            response=error_msg,
            title=title
        )
        return {
            "type": "text",
            "content": error_msg
        }

main.py :

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel,EmailStr
from services.responder_service import generate_response, rename_chat, delete_chat, get_user_chats, get_chat_history,handle_image_upload,signup_user,login_user
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import base64
import os
from datetime import datetime
import uuid
from fastapi import UploadFile, File, Form
from typing import Annotated
from fastapi.staticfiles import StaticFiles
from typing import Optional,List

app = FastAPI()

# Create image directory if it doesn't exist
os.makedirs("image", exist_ok=True)

# Serve static files from the image directory
app.mount("/image", StaticFiles(directory="image"), name="images")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class PromptRequest(BaseModel):
    prompt: str
    user_id: str
    chat_id: str
    title: Optional[str] = None

class ChatRenameRequest(BaseModel):
    user_id: str
    chat_id: str
    new_title: str

class ChatDeleteRequest(BaseModel):
    user_id: str
    chat_id: str

class ChatHistoryRequest(BaseModel):
    user_id: str
    chat_id: str
    limit: Optional[int] = 20
    
class ImagePromptRequest(BaseModel):
    prompt: Optional[str] = None
    user_id: str
    chat_id: str

class ManualSignupRequest(BaseModel):
    username: str
    email: EmailStr
    password: str

class GoogleSignupRequest(BaseModel):
    token: str  # Google ID token

class ManualLoginRequest(BaseModel):
    email: EmailStr
    password: str

class GoogleLoginRequest(BaseModel):
    token: str

@app.post("/login")
async def login_manual(request: ManualLoginRequest):
    result = login_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=401, detail=result["message"])


@app.post("/login/google")
async def login_google(request: GoogleLoginRequest):
    result = login_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse({
            "access_token": "dummy_token",  # optional: JWT later
            "user_data": result
        })
    else:
        raise HTTPException(status_code=401, detail=result["message"])
    
@app.post("/signup")
async def signup_manual(request: ManualSignupRequest):
    result = signup_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])

@app.post("/signup/google")
async def signup_google(request: GoogleSignupRequest):
    result = signup_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])
    
@app.post("/upload-image")
async def upload_image(
    images: List[UploadFile] = File(...),
    user_id: str = Form(...),
    chat_id: str = Form(...),
    prompt: Optional[str] = Form(None),
):
    try:
        image_data_list = []
        for image in images:
            image_data = await image.read()
            image_data_list.append(image_data)

        result = handle_image_upload(
            image_data_list=image_data_list,
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt
        )

        return JSONResponse({
            "status": "success",
            "image_ids": result.get("image_ids", []),
            "image_urls": result.get("image_urls", []),
            "llm_responses": [result.get("llm_response", "")]
        })

    except Exception as e:
        import traceback
        print("Upload image error traceback:", traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

def save_image(image_bytes: bytes) -> str:
    """Save image to /image folder and return filename"""
    filename = f"img_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:4]}.png"
    filepath = os.path.join("image", filename)
    
    with open(filepath, "wb") as f:
        f.write(image_bytes)
    
    return filename

@app.post("/chat")
async def chat(request: PromptRequest):
    try:
        response = generate_response(
            prompt=request.prompt,
            user_id=request.user_id,
            chat_id=request.chat_id,
            title=request.title
        )
        
        if response.get("type") == "image":
            if response.get("error") == "rate_limit":
                return JSONResponse({
                    "type": "text",
                    "content": "I'm getting rate limited by the image generation service. Please try again in a little while."
                })
            
            filename = save_image(response["image_bytes"])
            image_url = f"/image/{filename}"
            
            return JSONResponse({
                "type": "image",
                "image_url": image_url,
                "description": response.get("description", "Generated image"),
                "image_id": response.get("image_id", "")
            })
        else:
            return JSONResponse({
                "type": "text",
                "content": response["content"]
            })
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/rename-chat")
async def rename_chat_endpoint(request: ChatRenameRequest):
    try:
        rename_chat(request.user_id, request.chat_id, request.new_title)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/delete-chat")
async def delete_chat_endpoint(request: ChatDeleteRequest):
    try:
        delete_chat(request.user_id, request.chat_id)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/get_user_chats/{user_id}")
def get_user_chats_endpoint(user_id: str):
    try:
        chats = get_user_chats(user_id)

        # Convert Mongo ObjectId and datetime to JSON serializable
        for chat in chats:
            if "_id" in chat:
                chat["_id"] = str(chat["_id"])
            if "created_at" in chat:
                chat["created_at"] = chat["created_at"].isoformat()
            if "updated_at" in chat:
                chat["updated_at"] = chat["updated_at"].isoformat()
            if "messages" in chat:
                for message in chat["messages"]:
                    if "timestamp" in message and isinstance(message["timestamp"], datetime):
                        message["timestamp"] = message["timestamp"].isoformat()
        
        return JSONResponse(content={"chats": chats}, status_code=200)
    except Exception as e:
        print("💥 Error in get_user_chats_endpoint:", e)
        return JSONResponse(content={"detail": "Failed to fetch chats"}, status_code=500)

@app.post("/get_chat_history")
async def get_chat_history_endpoint(request: ChatHistoryRequest):
    try:
        history = get_chat_history(request.user_id, request.chat_id, request.limit)
        return JSONResponse({"history": history})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


<div
        ref={sidebarRef}
        className={`sidebar bg-color3 shadow-sm ${isSidebarVisible ? 'visible' : 'hidden'}`}
      >
        {/* Header row for close (slider) */}
        <div className="d-flex justify-content-between align-items-center px-3 pt-3">
          <div className="fw-bold fs-6 text-white"></div>

          {isSidebarVisible && (
            <button
              className="btn color-6 btn-sm"
              onClick={toggleSidebar}
              aria-label="Close sidebar"
              style={{ lineHeight: '1' }}
              title='close sidebar'
            >
              <i className="bi bi-layout-sidebar-inset-reverse"></i>
            </button>
          )}
        </div>

        {/* New Chat button */}
        <div className="d-flex px-2 pt-3">
          <button
            onClick={startNewChat}
            className="btn btn-outline-secondary border-0 text-start d-flex gap-2 w-100"
            disabled={isTyping || isProcessing}
          >
            <i className="fa-regular fa-pen-to-square pt-1"></i>
            <span className="text-truncate">New Chat</span>
          </button>
        </div>

        {/* Search Button */}
        <div className="p-2">
          <div className="input-group">
            <button
              className="btn btn-outline-secondary w-100 border-0 text-start  d-flex"
              onClick={() => setShowSearchModal(true)}
            >
              <i className="bi bi-search me-2"></i>
              <span className="text-truncate">Search chats</span>
            </button>
          </div>
        </div>
        <div className="p-3">
          <div className="d-flex justify-content-between align-items-center mb-2">
            <h6 className="text-muted mb-0">
              Recent chats
            </h6>
          </div>

          <div className="list-group list-group-flush chat-list">

            {chats.length === 0 ? (
              <div className="text-muted p-3 text-center">
                <i className="bi bi-chat-square-text fs-4 mb-2 d-block"></i>
                No active chats found
              </div>
            ) : (
              chats
                .sort((a, b) => new Date(b.updated_at || b.created_at) - new Date(a.updated_at || a.created_at))
                .map(chat => (
                  <div
                    key={chat.chat_id}
                    className={`list-group-item list-group-item-action border-0 px-3 py-2 ${activeChat === chat.chat_id ? 'active' : ''}`}
                    onClick={() => {
                      loadChat(chat);
                      setShowSearchModal(false);
                    }}
                  >
                    <div className="d-flex justify-content-between align-items-start">
                      <div className="flex-grow-1 me-2" style={{ minWidth: 0 }}>
                        <div
                          style={{
                            maxWidth: '180px',
                            height: '1.5rem',
                            lineHeight: '1.5rem',
                            fontSize: '0.95rem',
                            display: 'flex',
                            alignItems: 'center',
                          }}
                          onClick={(e) => {
                            if (!editingChatId) return; // ignore accidental clicks
                            e.stopPropagation();
                          }}
                        >
                          {editingChatId === chat.chat_id && renameSource === 'sidebar' ? (
                            <input
                              ref={renameInputRef}
                              type="text"
                              className="form-control form-control-sm fw-semibold border-0 p-0 m-0"
                              style={{
                                height: '1.5rem',
                                lineHeight: '1.5rem',
                                fontSize: '0.95rem',
                                backgroundColor: 'transparent',
                                boxShadow: 'none',
                              }}
                              value={tempTitle}
                              onChange={(e) => setTempTitle(e.target.value)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') handleRenameInline(chat.chat_id);
                                if (e.key === 'Escape') {
                                  setEditingChatId(null);
                                  setTempTitle('');
                                }
                              }}
                              onBlur={() => handleRenameInline(chat.chat_id)}
                              autoFocus
                            />
                          ) : (
                            <span
                              className="text-truncate text-start fw-semibold"
                              style={{
                                maxWidth: '100%',
                                cursor: 'pointer',
                                flex: 1,
                                whiteSpace: 'nowrap',
                                overflow: 'hidden',
                                textOverflow: 'ellipsis',
                              }}
                            >
                              {chat.highlightedTitle || chat.title}
                            </span>
                          )}

                        </div>
                      </div>

                      {!editingChatId && (
                        <div className="dropdown">
                          <button
                            className="btn btn-sm border-0 p-0 d-flex align-items-center justify-content-center chat-menu-trigger"
                            type="button"
                            data-bs-toggle="dropdown"
                            aria-expanded="false"
                            style={{ width: '24px', height: '24px' }}
                            onClick={(e) => e.stopPropagation()}
                          >
                            <div className="d-flex gap-1 color-7">
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                            </div>
                          </button>
                          <ul className="dropdown-menu dropdown-menu-end shadow-sm">
                            <li>
                              <button
                                className="dropdown-item text-light"
                                onClick={(e) => {
                                  e.preventDefault();
                                  setEditingChatId(chat.chat_id);
                                  setTempTitle(chat.title);
                                  setRenameSource('sidebar'); // Add this line
                                  setTimeout(() => {
                                    renameInputRef.current?.focus();
                                  }, 0);
                                }}
                              >
                                <i className="bi bi-pencil me-2"></i>Rename
                              </button>
                            </li>

                            <li>
                              <button
                                className="dropdown-item text-light"
                                onClick={(e) => {
                                  e.preventDefault();
                                  handleShare(chat.chat_id);
                                }}
                              >
                                <i className="bi bi-share me-2"></i>Share
                              </button>
                            </li>
                            <li><hr className="dropdown-divider" /></li>
                            <li>
                              <button
                                className="dropdown-item text-danger"
                                onClick={(e) => {
                                  e.preventDefault();
                                  confirmDelete(chat.chat_id);
                                }}
                              >
                                <i className="bi bi-trash me-2"></i>Delete
                              </button>
                            </li>
                          </ul>
                        </div>
                      )}
                    </div>
                  </div>
                ))
            )}
          </div>
        </div>
      </div>

.ms-collapsed-sidebar {
  margin-left: 60px; /* Match the width of collapsed sidebar */
  width: calc(100% - 60px);
}

home.jsx :

import React, { useState, useRef, useEffect } from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import './home.css';
import 'bootstrap-icons/font/bootstrap-icons.css';
import '@fortawesome/fontawesome-free/css/all.min.css';
import { toast, ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

function Home() {
  // State management
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatHistory, setChatHistory] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [isSidebarVisible, setIsSidebarVisible] = useState(true);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [chatToDelete, setChatToDelete] = useState(null);
  const [showRenameModal, setShowRenameModal] = useState(false);
  const [newChatTitle, setNewChatTitle] = useState('');
  const [chatToRename, setChatToRename] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [copiedMessageId, setCopiedMessageId] = useState(null);
  const [regeneratingMessageId, setRegeneratingMessageId] = useState(null);
  const [copiedCodeId, setCopiedCodeId] = useState(null);
  const [downloadedCodeId, setDownloadedCodeId] = useState(null);
  const [selectedImages, setSelectedImages] = useState([]);
  const [isUploadingImages, setIsUploadingImages] = useState(false);
  const [editingChatId, setEditingChatId] = useState(null);
  const [tempTitle, setTempTitle] = useState('');
  const [renameSource, setRenameSource] = useState(null);
  const [showSearchModal, setShowSearchModal] = useState(false);

  // Refs
  const messagesEndRef = useRef(null);
  const userId = useRef("user_" + Math.random().toString(36).substr(2, 9));
  const typingIntervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const botMessageIdRef = useRef(null);
  const inputRef = useRef(null);
  const sidebarRef = useRef(null);
  const typingMessageId = useRef(null);
  const fileInputRef = useRef(null);
  const renameInputRef = useRef(null);
  const renameFormRef = useRef(null);
  const chatInputRef = useRef(null);
  const searchInputRef = useRef(null);
  const [chats, setChats] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const user = JSON.parse(localStorage.getItem('user'));
  const user_id = user?.user_id;

  const TYPING_SPEED = 20; // milliseconds per character
  const MAX_IMAGES = 10;

  // Generate unique ID for messages
  const generateUniqueId = () => `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  // Effects
  useEffect(() => {
    // Cleanup on unmount
    return () => {
      if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
      if (abortControllerRef.current) abortControllerRef.current.abort();
      // Clean up object URLs
      selectedImages.forEach(img => URL.revokeObjectURL(img.preview));
    };
  }, [selectedImages]);

  useEffect(() => {
    if (inputValue === '' && inputRef.current) {
      inputRef.current.style.height = 'auto';
    }
  }, [inputValue]);


  useEffect(() => {
    // Focus input when not processing
    if (!isProcessing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isProcessing]);

  useEffect(() => {
    if (chatHistory.length === 0) {
      const defaultChat = {
        id: generateUniqueId(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory([defaultChat]);
      setActiveChat(defaultChat.id);
    }
  }, []);

  useEffect(() => {
    // Close sidebar when clicking outside
    const handleClickOutside = (event) => {
      if (sidebarRef.current && !sidebarRef.current.contains(event.target)) {
        if (window.innerWidth < 768) {
          setIsSidebarVisible(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  useEffect(() => {
    const fetchChats = async () => {
      try {
        const res = await fetch(`http://localhost:8000/get_user_chats/${user_id}`);
        if (!res.ok) {
          const errData = await res.json();
          throw new Error(errData.detail || "Server error");
        }
        const data = await res.json();
        setChats(data.chats);

      } catch (err) {
        setError(err.message || "Error fetching chats");
      } finally {
        setLoading(false);
      }
    };

    if (user_id) fetchChats();
  }, [user_id]);

  if (!user_id) return <p className="text-red-500">User not logged in.</p>;
  if (loading) return <p>Loading chats...</p>;
  if (error) return <p className="text-red-500">{error}</p>;

  // Image handling functions
  const handleImageUpload = (e) => {
    const files = Array.from(e.target.files);

    const validTypes = ['image/jpeg', 'image/png', 'image/webp'];
    const invalidFiles = files.filter(f => !validTypes.includes(f.type));
    if (invalidFiles.length > 0) {
      toast.error(`Invalid file type: ${invalidFiles.map(f => f.name).join(', ')}`);
      return;
    }

    const maxSize = 5 * 1024 * 1024;
    const oversizedFiles = files.filter(f => f.size > maxSize);
    if (oversizedFiles.length > 0) {
      toast.error(`Files too large (max 5MB): ${oversizedFiles.map(f => f.name).join(', ')}`);
      return;
    }

    if (files.length + selectedImages.length > MAX_IMAGES) {
      toast.warn(`You can upload maximum ${MAX_IMAGES} images`);
      return;
    }

    const newImages = files.map(file => ({
      file,
      id: generateUniqueId(),
      preview: URL.createObjectURL(file)   // 👈 preview for local display only
    }));

    setSelectedImages(prev => [...prev, ...newImages]);

    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // In your removeImage function
  const removeImage = (id) => {
    const imageToRemove = selectedImages.find(img => img.id === id);
    if (imageToRemove?.preview?.startsWith('blob:')) {
      URL.revokeObjectURL(imageToRemove.preview);
    }
    setSelectedImages(prev => prev.filter(img => img.id !== id));
  };

  const clearSelectedImages = () => {
    selectedImages.forEach(img => {
      if (img.preview?.startsWith('blob:')) {
        URL.revokeObjectURL(img.preview);
      }
    });
    setSelectedImages([]);
  };

  const uploadImages = async () => {
    if (selectedImages.length === 0) return null;

    setIsUploadingImages(true);
    try {
      const formData = new FormData();
      selectedImages.forEach((image) => {
        formData.append('images', image.file);
      });

      formData.append('user_id', user_id || userId.current);
      formData.append('chat_id', activeChat || 'default');
      if (inputValue.trim()) {
        formData.append('prompt', inputValue.trim());
      }

      const response = await fetch('http://localhost:8000/upload-image', {
        method: 'POST',
        body: formData,
      });

      const result = await response.json();

      if (!response.ok || result.status === 'error') {
        throw new Error(result.error || 'Failed to upload images');
      }

      return result;
    } catch (error) {
      console.error('Error uploading images:', error);
      toast.error(error.message || 'Failed to upload images');
      return null;
    } finally {
      setIsUploadingImages(false);
    }
  };

  // Chat operations
  const generateChatTitle = (messages) => {
    const firstUserMessage = messages.find(msg => msg.sender === 'user');
    if (firstUserMessage) {
      const shortText = firstUserMessage.text
        .replace(/\n/g, ' ')
        .trim()
        .slice(0, 30);
      return shortText + (firstUserMessage.text.length > 30 ? '...' : '');
    }
    return `New Chat ${new Date().toLocaleTimeString()}`;
  };

  const handleCopy = (text, id) => {
    navigator.clipboard.writeText(text);
    setCopiedMessageId(id);
    setTimeout(() => setCopiedMessageId(null), 1000);
  };

  const handleRegenerate = (id) => {
    setRegeneratingMessageId(id);
    regenerateResponse(id);
    setTimeout(() => setRegeneratingMessageId(null), 1000);
  };

  const handleCopyCode = (content, id) => {
    navigator.clipboard.writeText(content);
    setCopiedCodeId(id);
    setTimeout(() => setCopiedCodeId(null), 1000);
  };

  const handleDownloadCode = (content, lang, id) => {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `code-${lang || 'snippet'}.${lang || 'txt'}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setDownloadedCodeId(id);
    setTimeout(() => setDownloadedCodeId(null), 1000);
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
    });
  };

  const toggleSidebar = () => setIsSidebarVisible(!isSidebarVisible);

  const cancelRequest = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);

    if (typingMessageId.current) {
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId.current));
      typingMessageId.current = null;
    }

    botMessageIdRef.current = null;
    typingMessageId.current = null;
    setIsProcessing(false);
    setIsTyping(false);
    setMessages(prev => prev.filter(msg => msg.id !== typingMessageId.current));
  };

  const startNewChat = () => {
    if (isTyping || isProcessing) return;

    const emptyChat = chatHistory.find(chat => chat.messages.length === 0);
    if (emptyChat) {
      setActiveChat(emptyChat.id);
      setMessages([]);
    } else {
      const currentChat = chatHistory.find(chat => chat.id === activeChat);
      const hasBotMessage = messages.some(msg => msg.sender === 'bot');

      if (currentChat && hasBotMessage) {
        const updatedChat = {
          ...currentChat,
          messages: [...messages],
          title: currentChat.title === 'New Chat' ? generateChatTitle(messages) : currentChat.title,
          updatedAt: new Date().toISOString()
        };

        const updatedHistory = chatHistory.map(chat =>
          chat.id === activeChat ? updatedChat : chat
        );
        setChatHistory(updatedHistory);
      }

      const newChat = {
        id: generateUniqueId(),
        title: 'New Chat',
        messages: [],
        createdAt: new Date().toISOString()
      };
      setChatHistory(prev => [newChat, ...prev]);
      setMessages([]);
      setActiveChat(newChat.id);
    }
  };

  const loadChat = async (chat) => {
    try {
      // Transform messages to match frontend structure
      const transformedMessages = (chat.messages || []).flatMap(msg => {
        const messages = [];

        // Add user message
        if (msg.prompt) {
          messages.push({
            id: msg.message_id + '_user',
            text: msg.prompt,
            sender: 'user',
            timestamp: msg.timestamp
          });
        }
        // Add bot response
        if (msg.response) {
          messages.push({
            id: msg.message_id + '_bot',
            text: msg.response,
            sender: 'bot',
            timestamp: new Date(new Date(msg.timestamp).getTime() + 1000).toISOString()
          });
        }

        return messages;
      });

      setMessages(transformedMessages);
      setActiveChat(chat.chat_id);

      if (window.innerWidth < 768) {
        setIsSidebarVisible(false);
      }
    } catch (error) {
      console.error('Error loading chat:', error);
      toast.error("Failed to load chat");
    }
  };

  const handleShare = async (chatId) => {
    const chat = chats.find(c => c.id || c.chat_id === chatId);

    if (!chat) return;

    try {
      const content = chat.messages.map(msg => {
        const promptText = msg.prompt ? `You: ${msg.prompt}` : '';
        const responseText = msg.response ? `Assistant: ${msg.response}` : '';
        return [promptText, responseText].filter(Boolean).join('\n');
      }).join('\n\n');


      await navigator.clipboard.writeText(content);
    } catch (err) {
      toast.error("Failed to copy chat");
      console.error('Failed to copy chat:', err);
    }
  };

  const confirmDelete = (chatId) => {
    setChatToDelete(chatId);
    setShowDeleteModal(true);
  };

  const handleDelete = async () => {
    if (!chatToDelete) return;

    try {
      const response = await fetch('http://localhost:8000/delete-chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          user_id: user_id,
          chat_id: chatToDelete,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to delete chat');
      }

      // Update local state immediately
      setChats(prev => prev.filter(chat => chat.chat_id !== chatToDelete));

      if (activeChat === chatToDelete) {
        setMessages([]);
        setActiveChat(null);
      }
    } catch (error) {
      console.error('Error deleting chat:', error);
      toast.error("Failed to delete chat");
    } finally {
      setShowDeleteModal(false);
      setChatToDelete(null);
    }
  };

  const confirmRename = (chatId, currentTitle) => {
    setChatToRename(chatId);
    setNewChatTitle(currentTitle);
    setShowRenameModal(true);
  };

  const handleRenameInline = async (chatId) => {
    if (!tempTitle.trim()) {
      setEditingChatId(null);
      setTempTitle('');
      setRenameSource(null);
      return;
    }

    try {
      setChats(prev =>
        prev.map(chat =>
          chat.chat_id === chatId
            ? { ...chat, title: tempTitle.trim(), updatedAt: new Date().toISOString() }
            : chat
        )
      );

      await fetch('http://localhost:8000/rename-chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          user_id: user_id,
          chat_id: chatId,
          new_title: tempTitle.trim(),
        }),
      });

    } catch (err) {
      console.error('Rename failed:', err);
      toast.error("Rename failed");
      // Revert local changes if API fails
      setChats(prev => prev.map(chat =>
        chat.chat_id === chatId
          ? { ...chat, title: chat.title } // revert to original title
          : chat
      ));
    }

    setEditingChatId(null);
    setTempTitle('');
    setRenameSource(null);
  };

  const updateChatHistory = (userMessage, botMessage, title) => {
    if (!activeChat) {
      const newChat = {
        id: generateUniqueId(),
        title,
        messages: [userMessage, botMessage],
        createdAt: new Date().toISOString()
      };
      setChatHistory(prev => [newChat, ...prev]);
      setActiveChat(newChat.id);
    } else {
      setChatHistory(prev =>
        prev.map(chat =>
          chat.id === activeChat
            ? {
              ...chat,
              title: chat.title === 'New Chat' ? title : chat.title,
              messages: [...chat.messages, userMessage, botMessage],
              updatedAt: new Date().toISOString()
            }
            : chat
        )
      );
    }
  };

  const fetchChats = async () => {
    try {
      const res = await fetch(`http://localhost:8000/get_user_chats/${user_id}`);
      if (!res.ok) {
        const errData = await res.json();
        throw new Error(errData.detail || "Server error");
      }
      const data = await res.json();
      setChats(data.chats);

      // If there's a new chat, set it as active
      if (data.chats.length > 0 && !activeChat) {
        setActiveChat(data.chats[0].chat_id);
      }
    } catch (err) {
      setError(err.message || "Error fetching chats");
    } finally {
      setLoading(false);
    }
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if ((!inputValue.trim() && selectedImages.length === 0) || isProcessing) return;

    const userMessageText = inputValue.trim() || (selectedImages.length > 0 ? "Analyze these images" : "");
    if (!userMessageText) return;

    // Create user message
    const userMessage = {
      id: generateUniqueId(),
      text: userMessageText,
      type: selectedImages.length > 0 ? 'image-upload' : 'text',
      sender: 'user',
      timestamp: new Date().toISOString(),
      images: selectedImages.map(img => img.preview) || []
    };

    // Add user message immediately
    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    if (selectedImages.length > 0) clearSelectedImages();

    setIsProcessing(true);
    setIsTyping(true);

    // Add typing indicator
    const typingMessageId = generateUniqueId();
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: '',
      timestamp: new Date().toISOString()
    }]);

    abortControllerRef.current = new AbortController();
    const title = generateChatTitle([userMessage]);

    try {
      let response;

      if (selectedImages.length > 0) {
        const uploadResponse = await uploadImages();
        if (!uploadResponse) throw new Error('Image upload failed');

        userMessage.image_urls = uploadResponse.image_urls;
        const responseText = uploadResponse.llm_responses?.[0] || "Image processed";

        // Remove typing indicator and add bot message
        setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

        const botMessageId = generateUniqueId();
        botMessageIdRef.current = botMessageId;

        setMessages(prev => [...prev, {
          id: botMessageId,
          type: 'text',
          sender: 'bot',
          text: '',
          timestamp: new Date().toISOString()
        }]);

        // Typing effect for bot response
        let currentIndex = 0;
        typingIntervalRef.current = setInterval(() => {
          if (currentIndex < responseText.length) {
            setMessages(prev => prev.map(msg =>
              msg.id === botMessageId
                ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                : msg
            ));
            currentIndex++;
          } else {
            clearInterval(typingIntervalRef.current);
            typingIntervalRef.current = null;
            botMessageIdRef.current = null;
            setIsTyping(false);

            const finalMessage = {
              id: botMessageId,
              type: 'text',
              sender: 'bot',
              text: responseText,
              timestamp: new Date().toISOString()
            };

            updateChatHistory(userMessage, finalMessage, title);

            // Update the chats list in the sidebar
            fetchChats(); // Add this line to refresh the chat list
          }
        }, TYPING_SPEED);
        return;
      }

      // Handle text message
      response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          prompt: userMessageText,
          user_id: user_id,
          chat_id: activeChat,
          title: title
        }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) throw new Error(`Server error: ${response.status}`);
      const data = await response.json();

      // Remove typing indicator
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      const responseText = data.response || data.content || "I didn't understand that";
      const botMessageId = generateUniqueId();
      botMessageIdRef.current = botMessageId;

      // Add empty bot message
      setMessages(prev => [...prev, {
        id: botMessageId,
        type: 'text',
        sender: 'bot',
        text: '',
        timestamp: new Date().toISOString()
      }]);

      // Typing effect
      let currentIndex = 0;
      typingIntervalRef.current = setInterval(() => {
        if (currentIndex < responseText.length) {
          setMessages(prev => prev.map(msg =>
            msg.id === botMessageId
              ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
              : msg
          ));
          currentIndex++;
        } else {
          clearInterval(typingIntervalRef.current);
          typingIntervalRef.current = null;
          botMessageIdRef.current = null;
          setIsTyping(false);

          const finalMessage = {
            id: botMessageId,
            type: 'text',
            sender: 'bot',
            text: responseText,
            timestamp: new Date().toISOString()
          };

          updateChatHistory(userMessage, finalMessage, title);

          // Update the chats list in the sidebar
          fetchChats(); // Add this line to refresh the chat list
        }
      }, TYPING_SPEED);

    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev.filter(msg => msg.id !== typingMessageId), {
          id: generateUniqueId(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not get response. Please try again.',
          timestamp: new Date().toISOString()
        }]);
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const regenerateResponse = async (messageId) => {
    const messageToRegenerate = messages.find(msg => msg.id === messageId);
    if (!messageToRegenerate || messageToRegenerate.sender !== 'bot') return;

    // Find the previous user message that triggered this bot response
    const messageIndex = messages.findIndex(msg => msg.id === messageId);
    const previousUserMessage = messages[messageIndex - 1];

    if (!previousUserMessage || previousUserMessage.sender !== 'user') return;

    // Remove the old bot response
    setMessages(prev => prev.filter(msg => msg.id !== messageId));

    // Create new typing indicator
    const typingMessageId = generateUniqueId();
    setMessages(prev => [...prev, {
      id: typingMessageId,
      type: 'typing',
      sender: 'bot',
      text: '',
      timestamp: new Date().toISOString()
    }]);

    setIsProcessing(true);
    setIsTyping(true);
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token') || ''}`
        },
        body: JSON.stringify({
          prompt: previousUserMessage.text,
          user_id: user_id || userId.current,
          chat_id: activeChat,
          title: chats.find(c => c.chat_id === activeChat)?.title || 'New Chat',
        }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) throw new Error(`Server error: ${response.status}`);

      const data = await response.json();
      setMessages(prev => prev.filter(msg => msg.id !== typingMessageId));

      if (data.type === "image") {
        const botMessage = {
          id: generateUniqueId(),
          type: 'image',
          sender: 'bot',
          text: data.description || "Generated image",
          image_url: data.image_url,
          timestamp: new Date().toISOString()
        };
        setMessages(prev => [...prev, botMessage]);

        setIsProcessing(false);
        setIsTyping(false);
        if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
        if (abortControllerRef.current) abortControllerRef.current = null;
      } else {
        const responseText = data.content || JSON.stringify(data);
        const botMessageId = generateUniqueId();

        // Typing effect for the new response
        let currentIndex = 0;
        typingIntervalRef.current = setInterval(() => {
          if (currentIndex < responseText.length) {
            setMessages(prev =>
              prev.map(msg =>
                msg.id === botMessageId
                  ? { ...msg, text: responseText.substring(0, currentIndex + 1) }
                  : msg
              )
            );
            currentIndex++;
          } else {
            clearInterval(typingIntervalRef.current);
            typingIntervalRef.current = null;
            setIsTyping(false);
          }
        }, TYPING_SPEED);

        setMessages(prev => [...prev, {
          id: botMessageId,
          type: 'text',
          sender: 'bot',
          text: '',
          timestamp: new Date().toISOString()
        }]);
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Error:', err);
        setMessages(prev => [...prev, {
          id: generateUniqueId(),
          type: 'text',
          sender: 'bot',
          text: 'Error: Could not regenerate response. Please try again.',
          timestamp: new Date().toISOString()
        }]);
      }
    } finally {
      setIsProcessing(false);
      abortControllerRef.current = null;
    }
  };

  const formatMessageContent = (text, type = 'text') => {
    if (!text) return null;

    if (type === 'image') {
      return (
        <div className="generated-image-container">
          <img
            src={`http://localhost:8000${text}`}
            alt="Generated content"
            className="img-fluid rounded"
            style={{ maxHeight: '300px', maxWidth: '100%' }}
            onError={e => {
              e.target.onerror = null;
              e.target.src = '/placeholder-image.png';
            }}
          />
        </div>
      );
    }

    // Markdown inline formatting
    const processText = content => {
      if (!content) return '';
      let processed = content.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      processed = processed.replace(/\*(.+?)\*/g, '<em>$1</em>');
      processed = processed.replace(/`(.+?)`/g, '<code class="inline-code">$1</code>');
      return processed;
    };

    // Parse the content into blocks
    const blocks = [];
    const lines = text.split('\n');
    let inCode = false;
    let codeLang = '';
    let codeLines = [];
    let textLines = [];

    const pushTextBlock = () => {
      if (textLines.length > 0) {
        blocks.push({
          type: 'text',
          content: textLines.join('\n'),
        });
        textLines = [];
      }
    };

    lines.forEach((line) => {
      if (line.startsWith('```')) {
        if (!inCode) {
          // Starting a code block
          pushTextBlock();
          inCode = true;
          codeLang = line.replace('```', '').trim();
          codeLines = [];
        } else {
          // Ending a code block
          inCode = false;
          blocks.push({
            type: 'code',
            lang: codeLang,
            content: codeLines.join('\n'),
          });
          codeLang = '';
          codeLines = [];
        }
      } else if (inCode) {
        codeLines.push(line);
      } else {
        textLines.push(line);
      }
    });

    // Push any remaining blocks after loop
    pushTextBlock();
    if (codeLines.length > 0) {
      blocks.push({
        type: 'code',
        lang: codeLang,
        content: codeLines.join('\n'),
      });
    }

    // Render blocks with proper keys
    return (
      <div className="message-content">
        {blocks.map((block, index) => {
          if (block.type === 'code') {
            return (
              <div key={`code-${index}`} className="code-block-container position-relative mb-3">
                <div className="code-block bg-dark text-light p-3 rounded">
                  {block.lang && (
                    <div className="text-muted mb-2 font-monospace small">{block.lang}</div>
                  )}
                  <pre className="m-0">
                    <code className={`language-${block.lang || 'plaintext'}`}>
                      {block.content}
                    </code>
                  </pre>
                </div>
                <div className="code-actions position-absolute top-0 end-0 p-2 d-flex gap-1">
                  <button
                    className="btn btn-sm buttonn1"
                    onClick={() => handleCopyCode(block.content, block.id)}
                    title="Copy code"
                  >
                    <i className={copiedCodeId === block.id ? "bi bi-clipboard-check" : "bi bi-copy"}></i>
                    <span>
                      {copiedCodeId === block.id ? "  Copied" : "  Copy"}
                    </span>
                  </button>
                  <button
                    className="btn btn-sm buttonn1"
                    onClick={() => handleDownloadCode(block.content, block.lang, block.id)}
                    title="Download code"
                  >
                    <i className={downloadedCodeId === block.id ? "bi bi-check-square" : "bi bi-download"}></i>
                    <span>
                      {downloadedCodeId === block.id ? "  Downloaded" : "  Download"}
                    </span>
                  </button>
                </div>
              </div>
            );
          }

          // Process text blocks
          const paragraphs = block.content.split(/\n\s*\n/);
          return paragraphs
            .filter(p => p.trim())
            .map((paragraph, pIdx) => {
              const p = paragraph.trim();

              // Headings
              if (p.startsWith('### ')) {
                return (
                  <h1
                    key={`h1-${index}-${pIdx}`}
                    className="message-heading"
                    dangerouslySetInnerHTML={{ __html: processText(p.replace(/^### /, '')) }}
                  />
                );
              }
              if (p.startsWith('## ')) {
                return (
                  <h3
                    key={`h3-${index}-${pIdx}`}
                    className="message-heading"
                    dangerouslySetInnerHTML={{ __html: processText(p.replace(/^## /, '')) }}
                  />
                );
              }
              if (p.startsWith('# ')) {
                return (
                  <h3
                    key={`h3-${index}-${pIdx}`}
                    className="message-heading"
                    dangerouslySetInnerHTML={{ __html: processText(p.replace(/^# /, '')) }}
                  />
                );
              }

              // Lists
              if (p.startsWith('- ') || p.startsWith('* ')) {
                const items = p.split('\n');
                return (
                  <ul key={`ul-${index}-${pIdx}`} className="message-list">
                    {items.map((item, i) => (
                      <li
                        key={`li-${i}`}
                        dangerouslySetInnerHTML={{
                          __html: processText(item.replace(/^[-*] /, ''))
                        }}
                      />
                    ))}
                  </ul>
                );
              }

              if (/^\d+\.\s/.test(p)) {
                const items = p.split('\n');
                return (
                  <ol key={`ol-${index}-${pIdx}`} className="message-list">
                    {items.map((item, i) => (
                      <li
                        key={`li-${i}`}
                        dangerouslySetInnerHTML={{
                          __html: processText(item.replace(/^\d+\.\s/, ''))
                        }}
                      />
                    ))}
                  </ol>
                );
              }

              // Normal paragraph
              return (
                <p
                  key={`p-${index}-${pIdx}`}
                  className="message-paragraph"
                  dangerouslySetInnerHTML={{ __html: processText(p) }}
                />
              );
            });
        })}
      </div>
    );
  };

  const highlightSearchMatch = (text, query) => {
    if (!query) return text;

    const parts = text.split(new RegExp(`(${query})`, 'gi'));
    return parts.map((part, i) =>
      part.toLowerCase() === query.toLowerCase() ?
        <span key={i} className="text-danger fw-bold">{part}</span> :
        part
    );
  };

  const filteredChats = (chatList) => {
    if (!searchQuery) {
      return chatList.map(chat => ({
        ...chat,
        highlightedMessages: [], // Add empty array if no search
      }));
    }

    return chatList.filter(chat => {
      const titleMatch = chat.title?.toLowerCase().includes(searchQuery.toLowerCase());

      const messagesMatch = chat.messages?.some(msg => {
        return (
          (msg.prompt?.toLowerCase().includes(searchQuery.toLowerCase())) ||
          (msg.response?.toLowerCase().includes(searchQuery.toLowerCase()))
        );
      });

      return titleMatch || messagesMatch;
    }).map(chat => ({
      ...chat,
      highlightedTitle: highlightSearchMatch(chat.title || "", searchQuery),
      highlightedMessages: chat.messages?.map(msg => ({
        ...msg,
        highlightedPrompt: msg.prompt ? highlightSearchMatch(msg.prompt, searchQuery) : "",
        highlightedResponse: msg.response ? highlightSearchMatch(msg.response, searchQuery) : ""
      })) || []
    }));
  };

  const renderMessageContent = (msg) => {
    const messageText = msg.text || '';

    switch (msg.type) {
      case 'typing':
        return (
          <div className="d-flex align-items-center gap-2">
            <div className="spinner-grow spinner-grow-sm text-light" role="status" />
          </div>
        );

      case 'image':
        return (
          <div className="message-content">
            <div className="bot-message">
              <img
                src={`http://localhost:8000${msg.image_url}`}
                alt={messageText}
                className="img-fluid rounded"
                style={{ maxHeight: '300px' }}
              />
              <p className="mt-2 mb-0">{messageText}</p>
            </div>
          </div>
        );

      case 'image-upload':
        return (
          <div className="message-content d-flex flex-column gap-2">
            {/* Render all images if present */}
            {Array.isArray(msg.image_urls) && msg.image_urls.length > 0 && (
              <div className="d-flex flex-wrap gap-2">
                {msg.image_urls.map((url, idx) => (
                  <div
                    key={idx}
                    style={{ width: '70px', height: '70px', borderRadius: '6px', overflow: 'hidden' }}
                  >
                    <img
                      src={`http://localhost:8000${url}`}
                      alt={`Uploaded ${idx}`}
                      className="img-fluid w-100 h-100 object-fit-cover"
                      onError={(e) => {
                        e.target.onerror = null;
                        e.target.src = 'placeholder-image-url'; // 👈 Replace this with your placeholder
                      }}
                    />
                  </div>
                ))}
              </div>
            )}

            {/* TEXT below image, if exists */}
            {msg.text && (
              <p className="m-0" style={{ fontSize: '0.95rem', lineHeight: '1.5', color: '#ffffff' }}>
                {msg.text}
              </p>
            )}
          </div>

        );

      default:
        return (
          <div className="message-content">
            {msg.sender === 'bot' ? (
              <div className="bot-message">
                {formatMessageContent(msg.text, msg.type)}
              </div>
            ) : (
              <div className="user-message">
                {msg.text.split('\n').map((line, i) => <p key={i} className="mb-0">{line}</p>)}
              </div>
            )}
          </div>
        );
    }
  };

  const renderMessages = () => (
    <main className="flex-grow-1 overflow-auto p-3 bg-color1">
      <div className="d-flex flex-column gap-3">
        {messages.length === 0 ? (
          <div className="text-center mt-5">
            <div className="mb-4">
              <i className="bi bi-chat-square-text bg-color2 fs-1"></i>
            </div>
            <h5 className="bg-color2">Start a new conversation</h5>
            <p className="bg-color2">
              {selectedImages.length > 0 ?
                "You've selected images - add a message or send as is" :
                "Type a message below to begin chatting"}
            </p>
          </div>
        ) : (
          messages.map((msg) => (
            <div
              key={msg.message_id}
              className={`d-flex flex-column ${msg.sender === 'user' ? 'align-items-end' : 'align-items-start'
                }`}
            >
              <div
                className={`message-container p-3 rounded-3 ${msg.sender === 'user' ?
                  'primary text-white' :
                  msg.type === 'typing' ?
                    'shadow' :
                    'text-dark shadow-sm shadow'
                  }`}
                style={{ maxWidth: '85%' }}
              >
                {renderMessageContent(msg)}

                <div className="text-start mt-1">
                  <small className={`text-opacity-75 ${msg.sender === 'user' ? 'text-white' : ''
                    }`}>
                    {new Date(msg.timestamp).toLocaleTimeString([], {
                      hour: '2-digit',
                      minute: '2-digit'
                    })}
                  </small>
                </div>
              </div>

              {msg.sender === 'bot' && msg.type !== 'typing' && !isProcessing && !isTyping && (
                <div className="d-flex justify-content-start gap-2 mt-1 ms-3" style={{ maxWidth: '75%' }}>
                  <button
                    className="btn btn-sm buttonn"
                    onClick={() => handleCopy(msg.text, msg.id)}
                    title="Copy message"
                  >
                    <i className={copiedMessageId === msg.id ? "bi bi-clipboard-check" : "bi bi-copy"}></i>
                  </button>
                  <button
                    className="btn btn-sm buttonn"
                    onClick={() => handleRegenerate(msg.id)}
                    title="Regenerate response"
                    disabled={regeneratingMessageId === msg.id}
                  >
                    <i className={regeneratingMessageId === msg.id ? "bi bi-check" : "bi bi-arrow-repeat"}></i>
                  </button>
                </div>
              )}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>
    </main>
  );

  const renderInputArea = () => (
    <footer className="bg-color1 py-3 d-flex justify-content-center">
      <form onSubmit={handleSendMessage} style={{ width: '100%', maxWidth: '760px' }}>
        <div className="d-flex overflow-auto pb-2" style={{ gap: '8px' }}>
          {selectedImages.map((image) => (
            <div key={image.id} className="position-relative flex-shrink-0">
              <img
                src={image.preview}
                alt={`Preview ${image.id}`}
                style={{
                  height: '50px',
                  width: '50px',
                  objectFit: 'cover',
                  borderRadius: '4px'
                }}
              />
              <button
                type="button"
                onClick={() => removeImage(image.id)}
                aria-label="Remove image"
                className="btn btn-sm btn-danger p-0 d-flex align-items-center justify-content-center"
                style={{
                  position: 'absolute',
                  top: '-1px',
                  right: '-8px',
                  width: '15px',
                  height: '15px',
                  borderRadius: '50%'
                }}
              >
                <i className="bi bi-x" style={{ fontSize: '0.7rem' }}></i>
              </button>
            </div>
          ))}
        </div>
        <div
          className="shadow-sm px-3 py-3"
          style={{
            backgroundColor: 'rgb(80, 78, 78)',
            borderRadius: '30px',
            color: 'white',
            boxShadow: '12px 4px 4px 12px rgba(0, 0, 0, 0.17)',
          }}
        >
          {/* Image preview section */}
          {selectedImages.length > 0 && (
            <div className="mb-2">
              <div className="d-flex  justify-content-between align-items-center mb-2">
                <small className="text-muted">
                  {selectedImages.length} image{selectedImages.length !== 1 ? 's' : ''} selected
                </small>
                <button
                  type="button"
                  className="btn btn-sm btn-outline-danger"
                  onClick={clearSelectedImages}
                >
                  Clear all
                </button>
              </div>

            </div>
          )}

          {/* Text input */}
          <textarea
            rows={1}
            className="form-control bg-transparent text-light ps-3 pt-2"
            value={inputValue}
            onChange={(e) => {
              setInputValue(e.target.value);
              e.target.style.height = 'auto';
              e.target.style.height = `${Math.min(e.target.scrollHeight, 150)}px`;
            }}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey && !(isProcessing || isTyping)) {
                e.preventDefault();
                handleSendMessage(e);
              }
            }}
            placeholder={
              selectedImages.length > 0 ?
                "Add a message about these images (optional)" :
                "Type your message..."
            }
            ref={inputRef}
            style={{
              resize: 'none',
              border: 'none',
              boxShadow: 'none',
              minHeight: '44px',
              maxHeight: '180px',
              overflowY: 'auto',
              overflowWrap: 'break-word',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
              fontSize: '1rem',
            }}
          />

          {/* Input actions */}
          <div className="d-flex justify-content-between align-items-center mt-3 flex-wrap">
            <div className="d-flex align-items-center gap-3">
              <div className="position-relative">
                <input
                  type="file"
                  id="image-upload"
                  ref={fileInputRef}
                  accept="image/*"
                  className="d-none"
                  onChange={handleImageUpload}
                  multiple
                  disabled={selectedImages.length >= MAX_IMAGES}
                />
                <label
                  htmlFor="image-upload"
                  className={`btn btn-sm ${selectedImages.length >= MAX_IMAGES ? 'btn-outline-secondary disabled' : 'color-3'}`}
                  title={selectedImages.length >= MAX_IMAGES ?
                    `Maximum ${MAX_IMAGES} images allowed` : ""}
                >
                  <i className="bi bi-images me-1"></i>
                  {selectedImages.length > 0 ?
                    `${selectedImages.length}/${MAX_IMAGES}` : ''}
                </label>
              </div>
            </div>

            <button
              type="submit"
              onClick={cancelRequest}
              className={`btn rounded-pill px-4 d-flex align-items-center gap-2 ${isProcessing || isTyping || isUploadingImages ?
                'color-4' : 'color-4'
                }`}
            >

              {(isProcessing || isTyping || isUploadingImages) ? (
                <>
                  <span className="spinner-border spinner-border-sm spinner text-light" role="status" />
                </>
              ) : (
                <>
                  <i className="bi bi-send"></i>
                </>
              )}
            </button>
          </div>
        </div>

        <div className="text-center mt-2">
          <small className="text-white">
            {isProcessing || isTyping || isUploadingImages ? (
              <button
                type="button"
                className="btn btn-sm btn-outline-danger"
                onClick={cancelRequest}
              >
                <i className="bi bi-stop-circle me-1"></i> Stop generating
              </button>
            ) : (
              'Press Enter to send, Shift+Enter for new line'
            )}
          </small>
        </div>
      </form>
    </footer>
  );

  return (
    <div className="d-flex vh-100">
      {/* Delete Confirmation Modal */}
      <div className={`modal fade ${showDeleteModal ? 'show' : ''}`}
        style={{ display: showDeleteModal ? 'block' : 'none' }}
        tabIndex="-1">
        <div className="modal-dialog modal-dialog-centered">
          <div className="modal-content">
            <div className="modal-header">
              <h5 className="modal-title">Confirm Deletion</h5>
              <button type="button" className="btn-close" onClick={() => setShowDeleteModal(false)}></button>
            </div>
            <div className="modal-body">
              <p>Are you sure you want to delete this chat? This action cannot be undone.</p>
            </div>
            <div className="modal-footer">
              <button type="button" className="btn btn-outline-secondary" onClick={() => setShowDeleteModal(false)}>Cancel</button>
              <button type="button" className="btn btn-danger" onClick={handleDelete}>
                <i className="bi bi-trash me-1"></i> Delete
              </button>
            </div>
          </div>
        </div>
      </div>
      {showDeleteModal && <div className="modal-backdrop fade show"></div>}

      {/* Search Modal */}
      <div className={`modal fade ${showSearchModal ? 'show' : ''}`}
        style={{
          display: showSearchModal ? 'block' : 'none',
          background: 'rgba(26, 25, 25, 0.6)'
        }}
        tabIndex="-1"
        onClick={(e) => {
          // Close modal when clicking outside the modal content
          if (e.target === e.currentTarget) {
            setShowSearchModal(false);
          }
        }}
      >
        <div className="modal-dialog modal-dialog-centered justify-content-between align-items-center" style={{ maxWidth: '650px' }}>
          <div className="modal-content bg-color3 rounded-3 pb-3" style={{
            border: 'none',
            boxShadow: '0 0 20px rgba(0, 0, 0, 0.3)'
          }}>
            <div className="modal-header border-0">
              <div className="w-100">
                <div className="input-group">
                  <span className="input-group-text bg-transparent border-0">
                    <i className="bi bi-search text-muted"></i>
                  </span>
                  <input
                    type="text"
                    className="form-control border-0 shadow-none"
                    placeholder="Search chats..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    autoFocus
                    ref={searchInputRef}
                    style={{
                      fontSize: '1rem',
                      padding: '0.75rem 0',
                      backgroundColor: 'transparent'
                    }}
                  />
                  <button
                    className="input-group-text bg-transparent border-0"
                    type="button"
                    onClick={() => setShowSearchModal(false)}
                    style={{ cursor: 'pointer' }}
                  >
                    <i className="bi bi-x-lg bg-change"></i>
                  </button>
                </div>
              </div>
            </div>

            <div className="modal-body p-0">
              <div
                className="search-results"
                style={{
                  maxHeight: '60vh',
                  overflowY: 'auto',
                  padding: '0 1rem',
                }}
              >
                {filteredChats(chats).length === 0 ? (
                  <div className="text-muted text-center py-4">
                    <i className="bi bi-search fs-4 mb-2 d-block"></i>
                    No chats found
                  </div>
                ) : (
                  <div className="list-group list-group-flush">
                    {filteredChats(chats).map((chat) => (
                      <div
                        key={chat.chat_id}
                        className={`list-group-item list-group-item-action px-3 py-3 border-0 rounded-3 mb-1 ${activeChat === chat.chat_id ? 'active' : ''
                          }`}
                        style={{
                          cursor: 'pointer',
                          transition: 'background-color 0.2s ease',
                        }}
                        onClick={() => {
                          loadChat(chat);
                          setShowSearchModal(false);
                        }}
                      >
                        <div className="d-flex justify-content-between align-items-center">
                          <strong className="text-truncate">
                            {chat.highlightedTitle || chat.title}
                          </strong>
                          <small className="text-muted ms-2">
                            {formatDate(chat.updated_at || chat.created_at)}
                          </small>
                        </div>

                        {/* Message preview */}
                        {(chat.highlightedMessages || []).slice(0, 1).map((msg, idx) => (
                          <div
                            key={idx}
                            className="text-muted small mt-2"
                            style={{
                              maxHeight: '3rem',
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              whiteSpace: 'nowrap',
                            }}
                          >
                            {msg.prompt && (
                              <div>
                                <span className="fw-semibold">You:</span>{' '}
                                {msg.highlightedPrompt || msg.prompt}
                              </div>
                            )}
                            {msg.response && (
                              <div>
                                <span className="fw-semibold">Assistant:</span>{' '}
                                {msg.highlightedResponse || msg.response}
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
      {showSearchModal && <div className="modal-backdrop fade show"></div>}

      {/* Sidebar */}
      <div
        ref={sidebarRef}
        className={`sidebar shadow-sm d-flex flex-column ${isSidebarVisible ? 'visible' : 'hidden'}`}
      >
        {/* --- Sticky Header Section --- */}
        <div className="sticky-top z-3">
          {/* Close Button */}
          <div className="d-flex justify-content-between align-items-center px-3 pt-3">
            <div className="fw-bold fs-6 text-white"></div>

            {isSidebarVisible && (
              <button
                className="btn color-6 btn-sm"
                onClick={toggleSidebar}
                aria-label="Close sidebar"
                style={{ lineHeight: '1' }}
                title="close sidebar"
              >
                <i className="bi bi-layout-sidebar-inset-reverse"></i>
              </button>
            )}
          </div>

          {/* New Chat Button */}
          <div className="d-flex px-2 pt-3">
            <button
              onClick={startNewChat}
              className="btn btn-outline-secondary border-0 text-start d-flex gap-2 w-100"
              disabled={isTyping || isProcessing}
            >
              <i className="fa-regular fa-pen-to-square pt-1"></i>
              <span className="text-truncate">New Chat</span>
            </button>
          </div>

          {/* Search Button */}
          <div className="p-2">
            <div className="input-group">
              <button
                className="btn btn-outline-secondary w-100 border-0 text-start d-flex"
                onClick={() => setShowSearchModal(true)}
              >
                <i className="bi bi-search me-2"></i>
                <span className="text-truncate">Search chats</span>
              </button>
            </div>
          </div>
          <div className="d-flex justify-content-between align-items-center mb-0 ms-3">
            <h6 className="text-muted mb-2">Recent chats</h6>
          </div>
        </div>

        {/* --- Scrollable Chat List Section --- */}
        <div className="flex-grow-1 overflow-auto px-3 pt-2">

          <div className="list-group list-group-flush chat-list" style={{ paddingBottom: '1rem' }}>
            {chats.length === 0 ? (
              <div className="text-muted p-3 text-center">
                <i className="bi bi-chat-square-text fs-4 mb-2 d-block"></i>
                No active chats found
              </div>
            ) : (
              chats
                .sort((a, b) => new Date(b.updated_at || b.created_at) - new Date(a.updated_at || a.created_at))
                .map(chat => (
                  <div
                    key={chat.chat_id}
                    className={`list-group-item list-group-item-action border-0 px-3 py-2 ${activeChat === chat.chat_id ? 'active' : ''}`}
                    onClick={() => {
                      loadChat(chat);
                      setShowSearchModal(false);
                    }}
                  >
                    <div className="d-flex justify-content-between align-items-start">
                      <div className="flex-grow-1 me-2" style={{ minWidth: 0 }}>
                        <div
                          style={{
                            maxWidth: '180px',
                            height: '1.5rem',
                            lineHeight: '1.5rem',
                            fontSize: '0.95rem',
                            display: 'flex',
                            alignItems: 'center',
                          }}
                          onClick={(e) => {
                            if (!editingChatId) return;
                            e.stopPropagation();
                          }}
                        >
                          {editingChatId === chat.chat_id && renameSource === 'sidebar' ? (
                            <input
                              ref={renameInputRef}
                              type="text"
                              className="form-control form-control-sm fw-semibold border-0 p-0 m-0"
                              style={{
                                height: '1.5rem',
                                lineHeight: '1.5rem',
                                fontSize: '0.95rem',
                                backgroundColor: 'transparent',
                                boxShadow: 'none',
                              }}
                              value={tempTitle}
                              onChange={(e) => setTempTitle(e.target.value)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') handleRenameInline(chat.chat_id);
                                if (e.key === 'Escape') {
                                  setEditingChatId(null);
                                  setTempTitle('');
                                }
                              }}
                              onBlur={() => handleRenameInline(chat.chat_id)}
                              autoFocus
                            />
                          ) : (
                            <span
                              className="text-truncate text-start fw-semibold"
                              style={{
                                maxWidth: '100%',
                                cursor: 'pointer',
                                flex: 1,
                                whiteSpace: 'nowrap',
                                overflow: 'hidden',
                                textOverflow: 'ellipsis',
                              }}
                            >
                              {chat.highlightedTitle || chat.title}
                            </span>
                          )}
                          <small className="text-muted" style={{
                            flexShrink: 0,
                            whiteSpace: 'nowrap',
                            marginLeft: 'auto', // This will push it to the right
                          }}>
                            {formatDate(chat.updated_at || chat.created_at)}
                          </small>
                        </div>
                      </div>

                      {!editingChatId && (
                        <div className="dropdown">
                          <button
                            className="btn btn-sm border-0 p-0 d-flex align-items-center justify-content-center chat-menu-trigger"
                            type="button"
                            data-bs-toggle="dropdown"
                            aria-expanded="false"
                            style={{ width: '24px', height: '24px' }}
                            onClick={(e) => e.stopPropagation()}
                          >
                            <div className="d-flex gap-1 color-7">
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                              <span className="rounded-circle bg-secondary" style={{ width: '4px', height: '4px' }}></span>
                            </div>
                          </button>
                          <ul className="dropdown-menu dropdown-menu-end shadow-sm">
                            <li>
                              <button
                                className="dropdown-item text-light"
                                onClick={(e) => {
                                  e.preventDefault();
                                  setEditingChatId(chat.chat_id);
                                  setTempTitle(chat.title);
                                  setRenameSource('sidebar');
                                  setTimeout(() => {
                                    renameInputRef.current?.focus();
                                  }, 0);
                                }}
                              >
                                <i className="bi bi-pencil me-2"></i>Rename
                              </button>
                            </li>
                            <li>
                              <button
                                className="dropdown-item text-light"
                                onClick={(e) => {
                                  e.preventDefault();
                                  handleShare(chat.chat_id);
                                }}
                              >
                                <i className="bi bi-share me-2"></i>Share
                              </button>
                            </li>
                            <li><hr className="dropdown-divider" /></li>
                            <li>
                              <button
                                className="dropdown-item text-danger"
                                onClick={(e) => {
                                  e.preventDefault();
                                  confirmDelete(chat.chat_id);
                                }}
                              >
                                <i className="bi bi-trash me-2"></i>Delete
                              </button>
                            </li>
                          </ul>
                        </div>
                      )}
                    </div>
                  </div>
                ))
            )}
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className={`flex-grow-1 d-flex flex-column ${isSidebarVisible ? 'ms-sidebar' : 'ms-collapsed-sidebar'}`}>
        {/* Header */}
        <header className="bg-color p-4 d-flex align-items-center justify-content-between sticky-top">
          {!isSidebarVisible && (
            <div className="collapsed-sidebar d-flex flex-column align-items-center py-3 ">
              <button
                className="btn btn-sm color-5 "
                onClick={toggleSidebar}
                aria-label="Open sidebar"
                title='open sidebar'
              >
                <i className="bi bi-layout-sidebar-inset"></i>
              </button>

              <button
                onClick={startNewChat}
                className="btn btn-outline-secondary border-0 mt-5"
                disabled={isTyping || isProcessing}
              >
                <i className="fa-regular fa-pen-to-square "></i>
              </button>

              <button
                className="btn btn-outline-secondary border-0 mt-2"
                onClick={() => setShowSearchModal(true)}
              >
                <i className="bi bi-search "></i>
              </button>
            </div>
          )}

          <div className="d-flex justify-content-center align-items-center flex-grow-1">
            {editingChatId === activeChat && renameSource === 'header' ? (
              <input
                ref={renameInputRef}
                className="form-control text-center fw-semibold border-0"
                style={{
                  maxWidth: '360px',
                  height: '2.5rem',
                  fontSize: '1.5rem',
                  borderRadius: '8px',
                  padding: '0.25rem 0.75rem',
                  boxShadow: '0 0 0 0.15rem rgba(13,110,253,.25)',
                  transition: 'box-shadow 0.2s ease',
                }}
                value={tempTitle}
                onChange={(e) => setTempTitle(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') handleRenameInline(activeChat);
                  if (e.key === 'Escape') {
                    setEditingChatId(null);
                    setTempTitle('');
                  }
                }}
                onBlur={() => handleRenameInline(activeChat)}
                autoFocus
              />
            ) : (
              <h4
                className="mb-0 fw-semibold color-9 text-truncate text-center"
                onClick={() => {
                  const found = chats.find(c => c.chat_id === activeChat);
                  if (found) {
                    setEditingChatId(activeChat);
                    setTempTitle(found.title);
                    setRenameSource('header');
                    setTimeout(() => renameInputRef.current?.focus(), 0);
                  }
                }}
                style={{
                  maxWidth: '360px',
                  width: '100%',
                  height: '2.5rem',
                  lineHeight: '2.5rem',
                  fontSize: '1.5rem',
                  cursor: 'pointer',
                  padding: '0 0.75rem',
                  borderRadius: '8px',
                }}
              >
                {chats.find(c => c.chat_id === activeChat)?.title || 'New Chat'}
              </h4>
            )}
          </div>
        </header>

        {/* Messages Area */}
        {renderMessages()}

        {/* Input Area */}
        {renderInputArea()}
      </div>

      <ToastContainer
        position="top-right"
        autoClose={2000}
        hideProgressBar={false}
        newestOnTop={true}
        closeOnClick
        pauseOnHover={false}
        draggable
      />
    </div>
  );
}

export default Home;


responder_service.py :

import requests
from datetime import datetime
from pymongo import MongoClient
from duckduckgo_search import DDGS
import base64
from bson.binary import Binary
from io import BytesIO
import uuid
from PIL import Image
from bson import ObjectId
import os
from tempfile import NamedTemporaryFile
from typing import Union
import tempfile
from services.utils import save_image
import bcrypt
from google.oauth2 import id_token
from google.auth.transport import requests as google_requests

# Configuration
GROQ_API_KEY = "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"
STABILITY_API_KEY = "sk-3UnY9eVsTHi0V0NCCa5mVY61FwL4djjKakG7V3ePqs9vorgi"
API_URL = "https://api.groq.com/openai/v1/chat/completions"
STABILITY_API_URL = (
    "https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image"
)

# MongoDB setup
client = MongoClient("mongodb://localhost:27017/")
db = client["ai_new"]


uploaded_images_collection = db["uploaded_images"]
users_collection = db["users"]

user_info_collection = db["user_info"] 

def get_generated_images_collection():
    return db["uploaded_images"]

def save_uploaded_image(image_data: Union[bytes, str], user_id: str) -> str:
    """Save uploaded image (either bytes or base64) and return file path"""
    try:
        # Create user-specific directory if it doesn't exist
        user_dir = os.path.join(IMAGE_UPLOAD_DIR, user_id)
        os.makedirs(user_dir, exist_ok=True)

        # Generate unique filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"upload_{timestamp}_{uuid.uuid4().hex[:8]}.png"
        filepath = os.path.join(user_dir, filename)

        # Handle both base64 and raw bytes
        if isinstance(image_data, str):
            # Assume it's base64 if it's a string
            if image_data.startswith("data:image"):
                # Strip data URL prefix if present
                image_data = image_data.split(",", 1)[1]
            image_bytes = base64.b64decode(image_data)
        else:
            image_bytes = image_data

        # Save the image
        with open(filepath, "wb") as f:
            f.write(image_bytes)

        return filepath
    except Exception as e:
        print(f"Error saving uploaded image: {e}")
        raise

def process_image_with_llm(
    image_paths: list[str], prompt: str = None, history: list = None
) -> str:
    print("📤 Sending multiple images to LLM with prompt:", prompt)

    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    # Encode images
    image_parts = [
        {
            "type": "image_url",
            "image_url": {
                "url": f"data:image/png;base64,{base64.b64encode(open(p, 'rb').read()).decode('utf-8')}"
            },
        }
        for p in image_paths
    ]

    # Convert previous text + image history
    llm_messages = []
    if history:
        for msg in history:
            if msg.get("is_image", False):
                llm_messages.append(
                    {
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg['prompt']}",
                    }
                )
                llm_messages.append(
                    {
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg['response'].replace('IMAGE:', '')}",
                    }
                )
            else:
                llm_messages.append({"role": "user", "content": msg["prompt"]})
                llm_messages.append({"role": "assistant", "content": msg["response"]})

    # Add current image + prompt
    llm_messages.append(
        {"role": "user", "content": [{"type": "text", "text": prompt}] + image_parts}
    )

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": llm_messages,
        "max_tokens": 1500,
    }

    try:
        print("⏳ Requesting LLM...")
        response = requests.post(API_URL, headers=headers, json=data, timeout=60)
        print("✅ Response status:", response.status_code)
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    except Exception as e:
        print(f"❌ Error in LLM call: {e}")
        raise

def signup_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            # Google Sign-In case
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())
                
                # Extract all available Google profile information
                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),  # Profile picture URL
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")  # Unique Google ID
                }

                # Check if user already exists
                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success", 
                        "message": "User already exists", 
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create comprehensive user document
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,  # Store all Google data
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }
                
                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success", 
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Normal signup case (unchanged)
            username = data.get("username")
            email = data.get("email")
            password = data.get("password")

            if not all([username, email, password]):
                return {"status": "error", "message": "Missing fields"}

            if user_info_collection.find_one({"email": email}):
                return {"status": "error", "message": "Email already registered"}
            
            user_doc = {
                "username": username,
                "email": email,
                "password": password,
                "auth_type": "manual",
                "created_at": datetime.utcnow(),
                "last_login": datetime.utcnow()
            }
            inserted = user_info_collection.insert_one(user_doc)
            return {"status": "success", "user_id": str(inserted.inserted_id)}

    except Exception as e:
        print(f"Signup error: {e}")
        return {"status": "error", "message": str(e)}
    
def login_user(data: dict, is_google: bool = False) -> dict:
    try:
        if is_google:
            token = data.get("token")
            if not token:
                return {"status": "error", "message": "Missing Google token"}

            try:
                idinfo = id_token.verify_oauth2_token(token, google_requests.Request())

                google_profile_data = {
                    "email": idinfo.get("email"),
                    "username": idinfo.get("name"),
                    "given_name": idinfo.get("given_name"),
                    "family_name": idinfo.get("family_name"),
                    "locale": idinfo.get("locale"),
                    "picture_url": idinfo.get("picture"),
                    "email_verified": idinfo.get("email_verified", False),
                    "google_id": idinfo.get("sub")
                }

                existing = user_info_collection.find_one({"google_id": google_profile_data["google_id"]})
                if existing:
                    return {
                        "status": "success",
                        "message": "User already exists (logged in)",
                        "user_id": str(existing["_id"]),
                        "profile_data": existing.get("google_profile", {})
                    }

                # Create account if not exist
                user_doc = {
                    "username": google_profile_data["username"],
                    "email": google_profile_data["email"],
                    "auth_type": "google",
                    "google_profile": google_profile_data,
                    "created_at": datetime.utcnow(),
                    "last_login": datetime.utcnow()
                }

                inserted = user_info_collection.insert_one(user_doc)
                return {
                    "status": "success",
                    "message": "New Google user created",
                    "user_id": str(inserted.inserted_id),
                    "profile_data": google_profile_data
                }

            except Exception as e:
                return {"status": "error", "message": f"Invalid Google token: {str(e)}"}

        else:
            # Manual login
            email = data.get("email")
            password = data.get("password")

            if not all([email, password]):
                return {"status": "error", "message": "Missing fields"}

            user = user_info_collection.find_one({"email": email, "auth_type": "manual"})
            if not user:
                return {"status": "error", "message": "User not found"}

            if user["password"] != password:
                return {"status": "error", "message": "Incorrect password"}

            return {
                "status": "success",
                "message": "Login successful",
                "user_id": str(user["_id"]),
                "profile_data": {
                    "email": user["email"],
                    "username": user["username"],
                }
            }

    except Exception as e:
        return {"status": "error", "message": str(e)}

def handle_image_upload(image_data_list, user_id, chat_id, prompt=None):
    try:
        image_urls = []
        image_ids = []
        image_binaries = []
        temp_file_paths = []

        # Save and collect info
        for image_data in image_data_list:
            filename = save_image(image_data)
            image_url = f"/image/{filename}"
            image_urls.append(image_url)
            image_ids.append(str(uuid.uuid4()))
            image_binaries.append(Binary(image_data))

            # Save temp file for LLM
            with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp_file:
                tmp_file.write(image_data)
                temp_file_paths.append(tmp_file.name)

        # Process with LLM if prompt exists
        llm_response = None
        if prompt:
            try:
                history_messages = get_chat_history(user_id, chat_id)
                llm_response = process_image_with_llm(
                    temp_file_paths, prompt, history=history_messages
                )
            except Exception as e:
                print(f"Error processing image with LLM: {str(e)}")
                llm_response = f"Error analyzing images: {str(e)}"

        # Clean up temp files
        for path in temp_file_paths:
            try:
                os.remove(path)
            except:
                pass

        # Save to uploaded_images collection
        image_doc = {
            "user_id": user_id,
            "chat_id": chat_id,
            "prompt": prompt,
            "image_data": image_binaries,
            "image_urls": image_urls,
            "image_ids": image_ids,
            "llm_response": llm_response,
            "created_at": datetime.utcnow(),
        }
        uploaded_images_collection.insert_one(image_doc)

        # Prepare success response
        response_data = {
            "status": "success",
            "image_ids": image_ids,
            "image_urls": image_urls,
            "message": "Images uploaded successfully",
            "llm_response": llm_response,
            "response": llm_response  # For backward compatibility
        }

        # Save to user's chat collection
        user_chats_col = get_user_conversations_collection(user_id)
        chat_doc = {
            "message_id": str(ObjectId()),
            "user_id": user_id,
            "chat_id": chat_id,
            "type": "image-upload",
            "prompt": prompt or "",
            "image_urls": image_urls,
            "response": llm_response or "Images received",
            "timestamp": datetime.utcnow()
        }
        
        # Update or create chat document
        user_chats_col.update_one(
            {"chat_id": chat_id},
            {
                "$setOnInsert": {
                    "title": prompt[:50] + "..." if prompt else "Image Upload",
                    "created_at": datetime.utcnow()
                },
                "$push": {"messages": chat_doc},
                "$set": {"updated_at": datetime.utcnow()}
            },
            upsert=True
        )

        return response_data

    except Exception as e:
        error_msg = f"Error uploading images: {str(e)}"
        print(error_msg)
        return {
            "status": "error",
            "error": str(e),
            "message": error_msg,
            "response": error_msg  # Ensure this exists
        }

def get_user_conversations_collection(user_id: str):
    """Get or create a conversations collection for a specific user"""
    return db[f"{user_id}"]

def users_info(user_id: str):
    chats_collection = get_user_conversations_collection(user_id)
    
    chat_docs = chats_collection.find({}, {"chat_id": 1, "title": 1, "created_at": 1,"messages":1})
    
    return chat_docs


def get_generated_images_collection():
    """Get the global generated images collection"""
    return db["generated_images"]


def search_web(query: str) -> str:
    print("Searching the web for: ", query)
    results = []
    with DDGS() as ddgs:
        for r in ddgs.text(query, max_results=10):
            snippet = f"{r['title']}: {r['body']}"
            results.append(snippet)
    return "\n".join(results)


def should_generate_image(prompt: str) -> bool:
    """Use the LLM to determine if the prompt is requesting an image generation"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the following user prompt to determine if the user is requesting an image to be generated.

    User Prompt: "{prompt}"

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.5,
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining image generation need: {e}")
        return False

def generate_image(prompt: str, user_id: str) -> dict:
    """Generate an image using Stability AI's API"""
    print(f"Generating image for prompt: {prompt}")
    
    headers = {
        "Authorization": f"Bearer {STABILITY_API_KEY}",
        "Content-Type": "application/json"
    }
    
    data = {
        "text_prompts": [{"text": prompt, "weight": 1}],
        "cfg_scale": 7,
        "height": 1024,
        "width": 1024,
        "samples": 1,
        "steps": 30,
    }
    
    try:
        response = requests.post(STABILITY_API_URL, headers=headers, json=data, timeout=30)
        response.raise_for_status()
        response_data = response.json()
        
        if not response_data.get("artifacts"):
            raise Exception("No image artifacts in response")
            
        image_data = response_data["artifacts"][0]["base64"]
        image_bytes = base64.b64decode(image_data)
        
        # Save image information to the global images collection
        images_col = get_generated_images_collection()
        image_doc = {
            "user_id": user_id,
            "prompt": prompt,
            "generated_at": datetime.utcnow(),
            "model": "stable-diffusion-xl-1024-v1-0",
            "image_data": image_data  # Storing base64 for simplicity
        }
        image_id = images_col.insert_one(image_doc).inserted_id
        
        return {
            "type": "image",
            "image_bytes": image_bytes,
            "description": f"Generated image based on: '{prompt}'",
            "image_id": str(image_id)
        }
    except Exception as e:
        print(f"Image generation failed: {e}")
        raise

def should_perform_search(prompt: str, model_response: str) -> bool:
    """Determine if a web search is truly needed for this prompt"""
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json",
    }

    decision_prompt = f"""
    Analyze the user's prompt and decide if a web search is ABSOLUTELY NECESSARY to answer correctly.
    Web search should ONLY be performed if:
    1. The question is about very recent events (last few days/weeks)
    2. The question requires real-time data (stock prices, sports scores, etc.)
    3. Your initial response indicates you don't know the answer
    4. The question is about specific facts not in your training data (after 2023)

    User Prompt: "{prompt}"
    Your Initial Response: "{model_response}"

    If any of the above conditions are met, respond with 'YES'.
    Otherwise, respond with 'NO'.

    Respond ONLY with 'YES' or 'NO' and nothing else.
    """

    data = {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "messages": [{"role": "user", "content": decision_prompt}],
        "temperature": 0.1,  # Lower temperature for more deterministic responses
        "max_tokens": 3,
    }

    try:
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        result = response.json()
        decision = result["choices"][0]["message"]["content"].strip().upper()
        return decision == "YES"
    except Exception as e:
        print(f"Error determining search need: {e}")
        return False  # Default to no search if there's an error


def save_conversation(
    user_id: str,
    chat_id: str,
    prompt: str,
    response: str,
    title: str = None,
    is_image: bool = False,
):
    """Save conversation with title handling"""
    conversations_col = get_user_conversations_collection(user_id)

    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat:
        # New chat - use provided title or generate from prompt
        chat_title = (
            title
            if title
            else f"Chat: {prompt[:30]}..." if len(prompt) > 30 else f"Chat: {prompt}"
        )
        chat_doc = {
            "chat_id": chat_id,
            "user_id": user_id,
            "title": chat_title,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "messages": [],
        }
        conversations_col.insert_one(chat_doc)

    # Add message
    message = {
        "message_id": str(ObjectId()),
        "prompt": prompt,
        "response": response if not is_image else f"IMAGE:{response}",
        "is_image": is_image,
        "timestamp": datetime.utcnow(),
    }

    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$push": {"messages": message}, "$set": {"updated_at": datetime.utcnow()}},
    )

    print(f"Saved conversation for user {user_id} in chat {chat_id}")


def get_chat_history(user_id: str, chat_id: str, limit: int = 15):
    """Get the conversation history for a specific chat"""
    conversations_col = get_user_conversations_collection(user_id)
    chat = conversations_col.find_one({"chat_id": chat_id})

    if not chat or "messages" not in chat:
        return []

    # Return the most recent messages up to the limit
    return chat["messages"][-limit:]

def get_user_chats(user_id: str):
    conversations_col = get_user_conversations_collection(user_id)
    return list(
        conversations_col.find(
            {}, {"chat_id": 1, "title": 1, "created_at": 1, "updated_at": 1, "messages": 1}
        )
    )

def rename_chat(user_id: str, chat_id: str, new_title: str):
    """Rename a chat"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.update_one(
        {"chat_id": chat_id},
        {"$set": {"title": new_title, "updated_at": datetime.utcnow()}},
    )


def delete_chat(user_id: str, chat_id: str):
    """Delete a chat and its messages"""
    conversations_col = get_user_conversations_collection(user_id)
    conversations_col.delete_one({"chat_id": chat_id})


def generate_response(
    prompt: str, user_id: str = "guest", chat_id: str = "default", title: str = None
):
    print(f"Processing prompt for user {user_id} in chat {chat_id}: {prompt}")
    
    try:
        # Image generation logic
        if should_generate_image(prompt):
            try:
                image_result = generate_image(prompt, user_id)
                save_conversation(user_id, chat_id, prompt, image_result["image_id"], title=title, is_image=True)
                return {
                    "type": "image",
                    "image_bytes": image_result["image_bytes"],
                    "description": image_result.get("description", ""),
                    "image_id": image_result["image_id"],
                    "content": image_result.get("description", ""),
                    "response": image_result.get("description", "")  # Ensure this exists
                }
            except Exception as e:
                error_msg = f"Failed to generate image. Error: {str(e)}"
                return {
                    "type": "text",
                    "content": error_msg,
                    "response": error_msg
                }
                
        # Normal text response flow
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        history_messages = get_chat_history(user_id, chat_id)
        llm_messages = []

        # Prepare message history
        for msg in history_messages:
            content = msg.get("prompt", "") if msg.get("sender") == "user" else msg.get("response", "")
            if not content:
                continue
                
            if msg.get("is_image", False) or msg.get("type") == "image-upload":
                if msg.get("sender") == "user":
                    llm_messages.append({
                        "role": "user",
                        "content": f"(Image Upload)\nPrompt: {msg.get('prompt', '')}",
                    })
                else:
                    llm_messages.append({
                        "role": "assistant",
                        "content": f"(Image-based response)\n{msg.get('response', '').replace('IMAGE:', '')}",
                    })
            else:
                role = "user" if msg.get("sender") == "user" else "assistant"
                llm_messages.append({
                    "role": role,
                    "content": content
                })

        # Add current prompt
        llm_messages.append({
            "role": "user",
            "content": prompt,
        })

        try:
            # Initial LLM request
            response = requests.post(
                API_URL,
                headers=headers,
                json={
                    "model": "meta-llama/llama-4-scout-17b-16e-instruct",
                    "messages": llm_messages,
                    "temperature": 0.3,
                    "max_tokens": 2048,
                },
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
            reply = response_data["choices"][0]["message"]["content"]

            save_conversation(user_id, chat_id, prompt, reply, title=title)
            return {
                "type": "text",
                "content": reply,
                "response": reply  # Ensure this exists
            }

        except Exception as e:
            error_msg = f"Error processing your request: {str(e)}"
            print(f"API Error: {error_msg}")
            return {
                "type": "text",
                "content": error_msg,
                "response": error_msg
            }

    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        print(f"General Error: {error_msg}")
        return {
            "type": "text",
            "content": error_msg,
            "response": error_msg
        }


main.py :

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel,EmailStr
from services.responder_service import generate_response, rename_chat, delete_chat, get_user_chats, get_chat_history,handle_image_upload,signup_user,login_user
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import base64
import os
from datetime import datetime
import uuid
from fastapi import UploadFile, File, Form
from typing import Annotated
from fastapi.staticfiles import StaticFiles
from typing import Optional,List

app = FastAPI()

# Create image directory if it doesn't exist
os.makedirs("image", exist_ok=True)

# Serve static files from the image directory
app.mount("/image", StaticFiles(directory="image"), name="images")

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class PromptRequest(BaseModel):
    prompt: str
    user_id: str
    chat_id: str
    title: Optional[str] = None

class ChatRenameRequest(BaseModel):
    user_id: str
    chat_id: str
    new_title: str

class ChatDeleteRequest(BaseModel):
    user_id: str
    chat_id: str

class ChatHistoryRequest(BaseModel):
    user_id: str
    chat_id: str
    limit: Optional[int] = 20
    
class ImagePromptRequest(BaseModel):
    prompt: Optional[str] = None
    user_id: str
    chat_id: str

class ManualSignupRequest(BaseModel):
    username: str
    email: EmailStr
    password: str

class GoogleSignupRequest(BaseModel):
    token: str  # Google ID token

class ManualLoginRequest(BaseModel):
    email: EmailStr
    password: str

class GoogleLoginRequest(BaseModel):
    token: str

@app.post("/login")
async def login_manual(request: ManualLoginRequest):
    result = login_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=401, detail=result["message"])


@app.post("/login/google")
async def login_google(request: GoogleLoginRequest):
    result = login_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse({
            "access_token": "dummy_token",  # optional: JWT later
            "user_data": result
        })
    else:
        raise HTTPException(status_code=401, detail=result["message"])
    
@app.post("/signup")
async def signup_manual(request: ManualSignupRequest):
    result = signup_user(request.dict(), is_google=False)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])

@app.post("/signup/google")
async def signup_google(request: GoogleSignupRequest):
    result = signup_user(request.dict(), is_google=True)
    if result["status"] == "success":
        return JSONResponse(result)
    else:
        raise HTTPException(status_code=400, detail=result["message"])
    
@app.post("/upload-image")
async def upload_image(
    images: List[UploadFile] = File(...),
    user_id: str = Form(...),
    chat_id: str = Form(...),
    prompt: Optional[str] = Form(None),
):
    try:
        image_data_list = []
        for image in images:
            image_data = await image.read()
            image_data_list.append(image_data)

        result = handle_image_upload(
            image_data_list=image_data_list,
            user_id=user_id,
            chat_id=chat_id,
            prompt=prompt
        )

        return JSONResponse({
            "status": "success",
            "image_ids": result.get("image_ids", []),
            "image_urls": result.get("image_urls", []),
            "llm_responses": [result.get("llm_response", "")]
        })

    except Exception as e:
        import traceback
        print("Upload image error traceback:", traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

def save_image(image_bytes: bytes) -> str:
    """Save image to /image folder and return filename"""
    filename = f"img_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:4]}.png"
    filepath = os.path.join("image", filename)
    
    with open(filepath, "wb") as f:
        f.write(image_bytes)
    
    return filename

@app.post("/chat")
async def chat(request: PromptRequest):
    try:
        response = generate_response(
            prompt=request.prompt,
            user_id=request.user_id,
            chat_id=request.chat_id,
            title=request.title
        )
        
        if response.get("type") == "image":
            if response.get("error") == "rate_limit":
                return JSONResponse({
                    "type": "text",
                    "content": "I'm getting rate limited by the image generation service. Please try again in a little while."
                })
            
            filename = save_image(response["image_bytes"])
            image_url = f"/image/{filename}"
            
            return JSONResponse({
                "type": "image",
                "image_url": image_url,
                "description": response.get("description", "Generated image"),
                "image_id": response.get("image_id", "")
            })
        else:
            return JSONResponse({
                "type": "text",
                "content": response["content"]
            })
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/rename-chat")
async def rename_chat_endpoint(request: ChatRenameRequest):
    try:
        rename_chat(request.user_id, request.chat_id, request.new_title)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/delete-chat")
async def delete_chat_endpoint(request: ChatDeleteRequest):
    try:
        delete_chat(request.user_id, request.chat_id)
        return JSONResponse({"status": "success"})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/get_user_chats/{user_id}")
def get_user_chats_endpoint(user_id: str):
    try:
        chats = get_user_chats(user_id)

        # Convert Mongo ObjectId and datetime to JSON serializable
        for chat in chats:
            if "_id" in chat:
                chat["_id"] = str(chat["_id"])
            if "created_at" in chat:
                chat["created_at"] = chat["created_at"].isoformat()
            if "updated_at" in chat:
                chat["updated_at"] = chat["updated_at"].isoformat()
            if "messages" in chat:
                for message in chat["messages"]:
                    if "timestamp" in message and isinstance(message["timestamp"], datetime):
                        message["timestamp"] = message["timestamp"].isoformat()
        
        return JSONResponse(content={"chats": chats}, status_code=200)
    except Exception as e:
        print("💥 Error in get_user_chats_endpoint:", e)
        return JSONResponse(content={"detail": "Failed to fetch chats"}, status_code=500)

@app.post("/get_chat_history")
async def get_chat_history_endpoint(request: ChatHistoryRequest):
    try:
        history = get_chat_history(request.user_id, request.chat_id, request.limit)
        return JSONResponse({"history": history})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
        